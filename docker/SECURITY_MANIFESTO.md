# ðŸ›¡ï¸ GSD Secure: The "Full Containment" Manifesto

> **"Safe Intelligence"**: Why we run GSD Agents inside a Docker Container.

## 1. The Core Problem
Autonomous AI Agents (like GSD) act as "Junior Developers". To do their job, they need powerful permissions:
*   Read/Write files.
*   Execute shell commands.
*   Install dependencies.

Running an autonomous agent directly on your Host OS ("Bare Metal") is a critical risk.
**Why is this madness?**
1.  **Massive Data Loss**: LLMs hallucinate. If an agent tries to clean a build folder and accidentally runs `rm -rf ~` or `rm -rf /`, your personal photos, documents, and code are gone forever.
2.  **Malware Injection (Supply Chain)**: Agents often install libraries to solve problems (`npm install x`). If an agent installs a typosquatted malicious package, that malware runs immediately on your host, stealing browser cookies, SSH keys, and crypto wallets.
3.  **Environment Pollution**: Agents might change your global git config, node version, or python environment, breaking your other projects silently.
4.  **Data Exfiltration**: An agent running on your host can read *any* file it wants, including `.env` files from other projects or your `.ssh/id_rsa`.

5.  **The "Fatigue Factor" and Non-Technical Risks**:
    *   **Alert Fatigue**: When an agent asks for approval 50 times, you stop reading. The 51st command is the malicious one, and you click "Approve" out of habit.
    *   **Complexity Blindness**: For non-technical users, a command like `rm -rf $(npm bin)` looks harmless but can be destructive. Expecting a human to audit every shell command generated by an AI is unrealistic and unsafe.

**GSD Secure eliminates all these risks by physically and digitally isolating the execution.**

## 2. The Solution: Full Containment
We rejected the "Native Sandbox" approach (intercepting system calls) in favor of **Full Containment** (Docker).

| Feature | Option A: Native Sandbox | Option B: GSD Secure (Docker) |
| :--- | :--- | :--- |
| **Where Agent Lives** | On Host | **In Isolated Container** |
| **File System** | Read/Write Host | **Bind Mount Only** (Project Folder) |
| **Malware Risk** | Persistent | **Ephemeral** (Destroyed on exit) |
| **Security Level** | High Complexity / Leaky | **Kernel-Level Isolation** |

**Verdict**: We chose Option B. The Agent is not just handcuffed; it is in a separate room.

## 3. Architecture Overview
The GSD Secure environment consists of three layers:

### Layer 1: The "Space Suit" (Docker Image)
*   **Base**: `node:20-slim` (Minimal attack surface).
*   **Tools**: Pre-loaded with `git`, `python3`, `curl`.
    *   **Universal Auth Mounting**: Automatically detects and mounts keys for:
        *   Google Gemini (`~/.gemini`)
        *   Anthropic Claude (`~/.claude`)
        *   OpenCode (`~/.config/opencode`)
    *   **Identity Injection**: Passes the host's Git configuration (`user.name`, `email`) into the container, so commits belong to *you*.
*   **Auto-Stack**: Project dependencies are installed *inside* the container at runtime, keeping your Host OS clean.

### Layer 3: The "Brain" (Agent Awareness)
*   The GSD Agent is aware of this architecture.
*   It requests tools via `STACK.md` code blocks.
*   It assumes it is running as `root` *inside* the container, but maps to your user *outside*.

## 4. Security Guarantees
1.  **Zero Host Pollution**: `npm install` runs inside. `apt-get` runs inside. Your host remains untouched.
2.  **Scope Containment**: The agent can only see the folder you mounted (`/app`). It cannot access your Documents, Desktop, or System files.
3.  **Supply Chain Firewall**: If an agent downloads a malicious package, it infects only the disposable container. Restarting the sandbox eradicates the threat.
