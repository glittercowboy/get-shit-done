---
phase: 04-knowledge-extraction-hooks
plan: 05
type: execute
wave: 3
depends_on: ["04-04"]
files_modified:
  - get-shit-done/bin/knowledge-qa.js
  - get-shit-done/bin/knowledge-scan.js
autonomous: true

must_haves:
  truths:
    - "Q&A sessions generate questions based on knowledge gaps"
    - "User answers are stored as lessons in knowledge base"
    - "Session scanning extracts patterns from past conversations"
    - "Both flows integrate with knowledge storage"
  artifacts:
    - path: "get-shit-done/bin/knowledge-qa.js"
      provides: "Q&A session management"
      exports: ["generateQuestions", "processAnswer", "runQASession"]
    - path: "get-shit-done/bin/knowledge-scan.js"
      provides: "Session scanning for pattern extraction"
      exports: ["scanSession", "scanSessionLogs", "extractPatternsFromHistory"]
  key_links:
    - from: "get-shit-done/bin/knowledge-qa.js"
      to: "get-shit-done/bin/knowledge-evolution.js"
      via: "insertOrEvolve for answers"
      pattern: "insertOrEvolve.*lesson"
    - from: "get-shit-done/bin/knowledge-scan.js"
      to: "get-shit-done/bin/knowledge-extraction.js"
      via: "extractKnowledge call"
      pattern: "extractKnowledge.*content"
---

<objective>
Implement Q&A sessions for active learning and session scanning for batch pattern extraction

Purpose: Enable Claude to learn from direct user answers (KNOW-13) and extract patterns from past work (KNOW-14)
Output: knowledge-qa.js for Q&A flows, knowledge-scan.js for session scanning
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-knowledge-extraction-hooks/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Q&A session module</name>
  <files>get-shit-done/bin/knowledge-qa.js</files>
  <action>
Create `get-shit-done/bin/knowledge-qa.js` implementing KNOW-13:

**Question generation based on knowledge gaps:**
```javascript
const { knowledge } = require('./knowledge.js');

// Question templates for common knowledge gaps
const QUESTION_TEMPLATES = {
  preferences: [
    'What testing strategy do you prefer for this project?',
    'Do you have a preference for error handling patterns?',
    'What commit message style does this project use?',
    'How do you prefer to structure API responses?',
    'What naming conventions should we follow?'
  ],
  architecture: [
    'What is the preferred way to handle database connections?',
    'How should we structure shared utilities?',
    'What logging approach works best for this project?',
    'How do you prefer to handle configuration?'
  ],
  workflow: [
    'What should I always do before pushing code?',
    'Are there any patterns I should avoid in this codebase?',
    'What documentation style works best here?',
    'How should I handle breaking changes?'
  ]
};

async function analyzeKnowledgeGaps(options = {}) {
  const { scope = 'project', cwd = process.cwd() } = options;

  // Get existing knowledge statistics
  let stats = { decision: 0, lesson: 0, total: 0 };

  try {
    if (knowledge.isReady(scope, cwd)) {
      const result = await knowledge.getStats({ scope });
      stats = result.reduce((acc, s) => {
        acc[s.type] = s.total_count;
        acc.total += s.total_count;
        return acc;
      }, { decision: 0, lesson: 0, total: 0 });
    }
  } catch (err) {
    // Proceed with defaults
  }

  // Identify gaps based on what's missing
  const gaps = [];

  if (stats.lesson < 5) {
    gaps.push('preferences');  // Few lessons = need preference info
  }
  if (stats.decision < 3) {
    gaps.push('architecture');  // Few decisions = need architecture context
  }
  if (stats.total < 10) {
    gaps.push('workflow');  // Low total = need workflow patterns
  }

  return { stats, gaps };
}
```

**Generate questions based on gaps:**
```javascript
async function generateQuestions(options = {}) {
  const { maxQuestions = 5, scope = 'project' } = options;
  const { gaps } = await analyzeKnowledgeGaps({ scope });

  const questions = [];

  // Select questions from relevant categories
  for (const gap of gaps) {
    const templates = QUESTION_TEMPLATES[gap] || [];
    const remaining = maxQuestions - questions.length;

    if (remaining <= 0) break;

    // Take up to 2 questions per category
    const selected = templates.slice(0, Math.min(2, remaining));
    questions.push(...selected.map(q => ({
      question: q,
      category: gap
    })));
  }

  // If still need more, add from random categories
  while (questions.length < maxQuestions) {
    const categories = Object.keys(QUESTION_TEMPLATES);
    const cat = categories[Math.floor(Math.random() * categories.length)];
    const templates = QUESTION_TEMPLATES[cat];
    const q = templates[Math.floor(Math.random() * templates.length)];

    // Avoid duplicates
    if (!questions.some(existing => existing.question === q)) {
      questions.push({ question: q, category: cat });
    }
  }

  return questions.slice(0, maxQuestions);
}
```

**Process user answer:**
```javascript
async function processAnswer(question, answer, options = {}) {
  const { scope = 'global' } = options;  // User preferences go to global

  if (!answer || answer.trim().length < 10) {
    return { stored: false, reason: 'answer_too_short' };
  }

  // Format as Q&A pair
  const content = `Q: ${question}\nA: ${answer.trim()}`;

  try {
    const { insertOrEvolve } = require('./knowledge-evolution.js');
    const { generateEmbedding } = require('./embeddings.js');

    const embedding = await generateEmbedding(content);

    // Check if knowledge system is ready
    if (!knowledge.isReady(scope)) {
      return { stored: false, reason: 'knowledge_unavailable' };
    }

    const conn = await knowledge._getConnection(scope);
    const result = await insertOrEvolve(conn, {
      content,
      type: 'lesson',
      scope,
      embedding,
      metadata: {
        source: 'qa_session',
        question,
        category: options.category || 'general',
        answered_at: Date.now()
      }
    });

    return {
      stored: true,
      action: result.action,
      id: result.id
    };
  } catch (err) {
    return { stored: false, reason: err.message };
  }
}
```

**Interactive Q&A session runner:**
```javascript
async function runQASession(options = {}) {
  const { maxQuestions = 5, askUser, onComplete } = options;

  if (typeof askUser !== 'function') {
    throw new Error('askUser callback required for Q&A session');
  }

  const questions = await generateQuestions({ maxQuestions });
  const results = [];

  console.log('\n=== Knowledge Q&A Session ===');
  console.log('Help me learn your preferences and patterns.\n');

  for (const { question, category } of questions) {
    try {
      const answer = await askUser(question);

      if (answer && answer.trim()) {
        const result = await processAnswer(question, answer, {
          scope: 'global',
          category
        });
        results.push({ question, answer, ...result });

        if (result.stored) {
          console.log(`  -> Learned (${result.action})`);
        }
      } else {
        results.push({ question, skipped: true });
        console.log('  -> Skipped');
      }
    } catch (err) {
      results.push({ question, error: err.message });
    }
  }

  const summary = {
    total: questions.length,
    answered: results.filter(r => r.stored).length,
    skipped: results.filter(r => r.skipped).length,
    errors: results.filter(r => r.error).length,
    results
  };

  console.log(`\n=== Session Complete ===`);
  console.log(`Learned ${summary.answered} preferences\n`);

  if (onComplete) {
    onComplete(summary);
  }

  return summary;
}
```

**Exports:**
- QUESTION_TEMPLATES
- analyzeKnowledgeGaps(options?) -> { stats, gaps }
- generateQuestions(options?) -> Question[]
- processAnswer(question, answer, options?) -> { stored, action?, reason? }
- runQASession(options) -> summary
  </action>
  <verify>
```bash
cd get-shit-done && node -e "
const { generateQuestions, analyzeKnowledgeGaps, processAnswer } = require('./bin/knowledge-qa.js');

(async () => {
  // Test gap analysis
  const gaps = await analyzeKnowledgeGaps();
  console.log('Knowledge gaps:', gaps.gaps);
  console.log('Stats:', gaps.stats);

  // Generate questions
  const questions = await generateQuestions({ maxQuestions: 3 });
  console.log('\\nGenerated questions:');
  questions.forEach(q => console.log('-', q.category + ':', q.question));
})();
"
```
  </verify>
  <done>
- analyzeKnowledgeGaps identifies missing knowledge categories
- generateQuestions creates relevant questions based on gaps
- processAnswer stores Q&A pairs as lessons
- runQASession orchestrates interactive Q&A flow
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session scanning module</name>
  <files>get-shit-done/bin/knowledge-scan.js</files>
  <action>
Create `get-shit-done/bin/knowledge-scan.js` implementing KNOW-14:

**Session log parsing:**
```javascript
const fs = require('fs');
const path = require('path');
const { extractKnowledge } = require('./knowledge-extraction.js');

// Parse session logs (simplified JSONL format)
function parseSessionLog(logPath) {
  try {
    const content = fs.readFileSync(logPath, 'utf8');
    const lines = content.split('\n').filter(line => line.trim());

    const messages = [];
    for (const line of lines) {
      try {
        const entry = JSON.parse(line);
        if (entry.role && entry.content) {
          messages.push(entry);
        }
      } catch (parseErr) {
        // Skip invalid lines
      }
    }

    return messages;
  } catch (err) {
    console.warn(`[scan] Failed to parse ${logPath}:`, err.message);
    return [];
  }
}

// Get assistant responses from parsed messages
function getAssistantContent(messages) {
  return messages
    .filter(m => m.role === 'assistant')
    .map(m => m.content)
    .join('\n\n---\n\n');
}
```

**Scan single session:**
```javascript
async function scanSession(sessionContent, options = {}) {
  const { source = 'session_scan' } = options;

  // Extract knowledge from session content
  const extraction = extractKnowledge(sessionContent, {
    debug: process.env.GSD_DEBUG
  });

  if (extraction.extractions.length === 0) {
    return {
      success: true,
      extractions: 0,
      stats: {
        raw: extraction.total_raw,
        filtered: extraction.total_filtered
      }
    };
  }

  // Process extractions
  let processResult = { created: 0, evolved: 0, skipped: 0 };

  try {
    const { processExtractionBatch } = require('./knowledge-evolution.js');
    const { knowledge } = require('./knowledge.js');

    if (knowledge.isReady(options.scope || 'project')) {
      const conn = await knowledge._getConnection(options.scope || 'project');
      processResult = await processExtractionBatch(conn, extraction.extractions, {
        scope: options.scope || 'project',
        source
      });
    }
  } catch (err) {
    console.warn('[scan] Processing failed:', err.message);
    processResult.error = err.message;
  }

  return {
    success: true,
    extractions: extraction.total_deduplicated,
    stats: {
      raw: extraction.total_raw,
      filtered: extraction.total_filtered,
      deduplicated: extraction.total_deduplicated,
      ...processResult
    }
  };
}
```

**Scan session log files:**
```javascript
async function scanSessionLogs(logPaths, options = {}) {
  const { verbose = false } = options;
  const results = {
    scanned: 0,
    skipped: 0,
    total_extractions: 0,
    total_created: 0,
    total_evolved: 0,
    errors: []
  };

  for (const logPath of logPaths) {
    if (!fs.existsSync(logPath)) {
      results.skipped++;
      continue;
    }

    try {
      const messages = parseSessionLog(logPath);
      const content = getAssistantContent(messages);

      if (!content.trim()) {
        results.skipped++;
        continue;
      }

      const scanResult = await scanSession(content, {
        ...options,
        source: `session_scan:${path.basename(logPath)}`
      });

      results.scanned++;
      results.total_extractions += scanResult.extractions;
      results.total_created += scanResult.stats.created || 0;
      results.total_evolved += scanResult.stats.evolved || 0;

      if (verbose) {
        console.log(`[scan] ${path.basename(logPath)}: ${scanResult.extractions} extractions`);
      }
    } catch (err) {
      results.errors.push({ file: logPath, error: err.message });
    }
  }

  return results;
}
```

**Extract patterns from conversation history:**
```javascript
async function extractPatternsFromHistory(history, options = {}) {
  // history = array of { role, content } messages
  const assistantContent = history
    .filter(m => m.role === 'assistant')
    .map(m => m.content)
    .join('\n\n---\n\n');

  return scanSession(assistantContent, {
    ...options,
    source: 'history_scan'
  });
}
```

**Find session logs in project:**
```javascript
function findSessionLogs(searchPath = '.', options = {}) {
  const { maxAge = 30 * 24 * 60 * 60 * 1000 } = options;  // 30 days default
  const now = Date.now();
  const logs = [];

  // Common session log locations
  const patterns = [
    '.claude/sessions/*.jsonl',
    '.planning/sessions/*.jsonl',
    '.claude-sessions/*.jsonl'
  ];

  for (const pattern of patterns) {
    const dir = path.dirname(pattern);
    const fullDir = path.join(searchPath, dir);

    if (fs.existsSync(fullDir)) {
      try {
        const files = fs.readdirSync(fullDir);
        for (const file of files) {
          if (file.endsWith('.jsonl')) {
            const filePath = path.join(fullDir, file);
            const stat = fs.statSync(filePath);

            // Filter by age
            if (now - stat.mtimeMs <= maxAge) {
              logs.push(filePath);
            }
          }
        }
      } catch (err) {
        // Skip inaccessible directories
      }
    }
  }

  return logs;
}
```

**Exports:**
- parseSessionLog(logPath) -> Message[]
- getAssistantContent(messages) -> string
- scanSession(content, options?) -> { success, extractions, stats }
- scanSessionLogs(logPaths, options?) -> { scanned, skipped, total_*, errors }
- extractPatternsFromHistory(history, options?) -> { success, extractions, stats }
- findSessionLogs(searchPath?, options?) -> string[]
  </action>
  <verify>
```bash
cd get-shit-done && node -e "
const { scanSession, findSessionLogs, extractPatternsFromHistory } = require('./bin/knowledge-scan.js');

(async () => {
  // Test session scanning
  const testContent = \`
Let's use SQLite for the database layer.
The trick is to enable WAL mode for concurrency.
I decided to go with better-sqlite3 for performance.
Note: Always close connections in tests.
\`;

  const result = await scanSession(testContent);
  console.log('Scan result:', result);

  // Test history extraction
  const history = [
    { role: 'user', content: 'How should I handle errors?' },
    { role: 'assistant', content: 'The trick is to use try/catch with specific error types.' }
  ];

  const historyResult = await extractPatternsFromHistory(history);
  console.log('History result:', historyResult);

  // Find logs (likely empty in test)
  const logs = findSessionLogs('.');
  console.log('Found logs:', logs.length);
})();
"
```
  </verify>
  <done>
- scanSession extracts knowledge from session content
- scanSessionLogs batch processes multiple log files
- extractPatternsFromHistory works with conversation arrays
- findSessionLogs discovers session log files
  </done>
</task>

</tasks>

<verification>
All extraction flow tests pass:
- Q&A generates relevant questions based on knowledge gaps
- User answers stored as lessons in knowledge base
- Session scanning extracts from past conversation logs
- History extraction works with structured message arrays
- Both flows integrate with knowledge evolution
</verification>

<success_criteria>
1. generateQuestions creates questions based on identified gaps
2. processAnswer stores Q&A pairs as lessons
3. runQASession orchestrates interactive learning
4. scanSession extracts from session content
5. scanSessionLogs batch processes multiple files
6. extractPatternsFromHistory works with message arrays
7. All flows store via knowledge evolution (dedup aware)
</success_criteria>

<output>
After completion, create `.planning/phases/04-knowledge-extraction-hooks/04-05-SUMMARY.md`
</output>
