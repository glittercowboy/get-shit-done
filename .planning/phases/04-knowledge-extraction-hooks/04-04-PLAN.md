---
phase: 04-knowledge-extraction-hooks
plan: 04
type: execute
wave: 2
depends_on: ["04-02"]
files_modified:
  - get-shit-done/bin/hooks/config.js
  - get-shit-done/bin/hooks/session-end.js
  - get-shit-done/bin/hooks/per-turn.js
autonomous: true

must_haves:
  truths:
    - "Hooks can be enabled/disabled via configuration"
    - "Session-end mode batches extraction at conversation end"
    - "Per-turn mode extracts after each Claude response"
    - "Configuration supports switching between timing modes"
  artifacts:
    - path: "get-shit-done/bin/hooks/config.js"
      provides: "Hook configuration management"
      exports: ["loadHookConfig", "saveHookConfig", "DEFAULT_HOOK_CONFIG"]
    - path: "get-shit-done/bin/hooks/session-end.js"
      provides: "Session-end batch extraction"
      exports: ["sessionEndHook", "registerSessionEndHook"]
    - path: "get-shit-done/bin/hooks/per-turn.js"
      provides: "Per-turn extraction"
      exports: ["perTurnHook", "createPerTurnMiddleware"]
  key_links:
    - from: "get-shit-done/bin/hooks/session-end.js"
      to: "get-shit-done/bin/knowledge-extraction.js"
      via: "extractKnowledge call"
      pattern: "extractKnowledge.*responseText"
    - from: "get-shit-done/bin/hooks/per-turn.js"
      to: "get-shit-done/bin/knowledge-evolution.js"
      via: "insertOrEvolve call"
      pattern: "insertOrEvolve.*content"
---

<objective>
Implement hook integration with configurable timing modes for passive knowledge capture

Purpose: Enable automatic extraction from Claude conversations (HOOK-05, HOOK-06, HOOK-07, HOOK-08)
Output: Hook configuration and timing mode implementations (session-end, per-turn)
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-knowledge-extraction-hooks/04-RESEARCH.md

# Extraction module from 04-02
@get-shit-done/bin/knowledge-extraction.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hook configuration module</name>
  <files>get-shit-done/bin/hooks/config.js</files>
  <action>
Create directory and configuration module:

```bash
mkdir -p get-shit-done/bin/hooks
```

Create `get-shit-done/bin/hooks/config.js`:

**Default configuration (HOOK-07, HOOK-08):**
```javascript
const fs = require('fs');
const path = require('path');

const DEFAULT_HOOK_CONFIG = {
  enabled: true,                    // HOOK-07: Enable/disable
  timing: 'session-end',            // HOOK-05/06: 'session-end' or 'per-turn'
  quality_gates: {
    min_length: 20,                 // HOOK-04
    require_technical_signal: true  // HOOK-04
  },
  deduplication: {
    exact_threshold: 1.0,
    canonical_threshold: 0.95,
    embedding_threshold: 0.88       // KNOW-16
  },
  evolution: {
    similarity_min: 0.65,           // KNOW-17
    similarity_max: 0.88
  },
  extraction: {
    decisions: true,                // HOOK-02
    lessons: true,                  // HOOK-03
    summaries: false                // Too noisy by default
  },
  scope: 'project'                  // Default extraction scope
};
```

**Config file paths:**
```javascript
function getConfigPaths(cwd = process.cwd()) {
  return {
    project: path.join(cwd, '.planning', 'knowledge', 'hooks.json'),
    global: path.join(process.env.HOME, '.claude', 'knowledge', 'hooks.json')
  };
}

function ensureConfigDir(configPath) {
  const dir = path.dirname(configPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}
```

**Load config with fallback:**
```javascript
function loadHookConfig(options = {}) {
  const { scope = 'project', cwd = process.cwd() } = options;
  const paths = getConfigPaths(cwd);
  const configPath = paths[scope] || paths.project;

  try {
    if (fs.existsSync(configPath)) {
      const raw = fs.readFileSync(configPath, 'utf8');
      const loaded = JSON.parse(raw);
      // Merge with defaults for any missing fields
      return {
        ...DEFAULT_HOOK_CONFIG,
        ...loaded,
        quality_gates: { ...DEFAULT_HOOK_CONFIG.quality_gates, ...loaded.quality_gates },
        deduplication: { ...DEFAULT_HOOK_CONFIG.deduplication, ...loaded.deduplication },
        evolution: { ...DEFAULT_HOOK_CONFIG.evolution, ...loaded.evolution },
        extraction: { ...DEFAULT_HOOK_CONFIG.extraction, ...loaded.extraction }
      };
    }
  } catch (err) {
    console.warn('[hooks] Failed to load config:', err.message);
  }

  return { ...DEFAULT_HOOK_CONFIG };
}
```

**Save config:**
```javascript
function saveHookConfig(config, options = {}) {
  const { scope = 'project', cwd = process.cwd() } = options;
  const paths = getConfigPaths(cwd);
  const configPath = paths[scope] || paths.project;

  try {
    ensureConfigDir(configPath);
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    return { success: true, path: configPath };
  } catch (err) {
    return { success: false, error: err.message };
  }
}
```

**Enable/disable helpers (HOOK-07):**
```javascript
function setHooksEnabled(enabled, options = {}) {
  const config = loadHookConfig(options);
  config.enabled = enabled;
  return saveHookConfig(config, options);
}

function setHooksTiming(timing, options = {}) {
  if (!['session-end', 'per-turn'].includes(timing)) {
    return { success: false, error: `Invalid timing: ${timing}` };
  }
  const config = loadHookConfig(options);
  config.timing = timing;
  return saveHookConfig(config, options);
}

function isHooksEnabled(options = {}) {
  const config = loadHookConfig(options);
  return config.enabled;
}
```

**Exports:**
- DEFAULT_HOOK_CONFIG
- getConfigPaths(cwd?) -> { project, global }
- loadHookConfig(options?) -> config
- saveHookConfig(config, options?) -> { success, path? | error? }
- setHooksEnabled(enabled, options?) -> { success, ... }
- setHooksTiming(timing, options?) -> { success, ... }
- isHooksEnabled(options?) -> boolean
  </action>
  <verify>
```bash
cd get-shit-done && node -e "
const { loadHookConfig, saveHookConfig, DEFAULT_HOOK_CONFIG, isHooksEnabled } = require('./bin/hooks/config.js');

console.log('Default config:', DEFAULT_HOOK_CONFIG.timing, DEFAULT_HOOK_CONFIG.enabled);
console.log('Loaded config:', loadHookConfig().timing);
console.log('Is enabled:', isHooksEnabled());

// Test save (to temp location)
const testConfig = { ...DEFAULT_HOOK_CONFIG, timing: 'per-turn' };
console.log('Save result:', saveHookConfig(testConfig));
console.log('Reloaded timing:', loadHookConfig().timing);
"
```
  </verify>
  <done>
- Configuration loads from .planning/knowledge/hooks.json
- Falls back to DEFAULT_HOOK_CONFIG if missing
- setHooksEnabled and setHooksTiming modify config
- isHooksEnabled returns current enabled state
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session-end hook</name>
  <files>get-shit-done/bin/hooks/session-end.js</files>
  <action>
Create `get-shit-done/bin/hooks/session-end.js` (HOOK-06):

**Session-end extraction:**
```javascript
const { loadHookConfig, isHooksEnabled } = require('./config.js');
const { extractKnowledge } = require('../knowledge-extraction.js');

// Conversation history accumulator
let conversationHistory = [];

function addToHistory(message) {
  conversationHistory.push({
    role: message.role,
    content: message.content,
    timestamp: Date.now()
  });
}

function getConversationHistory() {
  return [...conversationHistory];
}

function clearConversationHistory() {
  conversationHistory = [];
}

// Get all Claude responses from history
function getAssistantResponses() {
  return conversationHistory
    .filter(msg => msg.role === 'assistant')
    .map(msg => msg.content);
}
```

**Session-end extraction logic:**
```javascript
async function sessionEndHook(options = {}) {
  const config = loadHookConfig(options);

  if (!config.enabled || config.timing !== 'session-end') {
    return { skipped: true, reason: 'disabled_or_wrong_timing' };
  }

  const responses = getAssistantResponses();
  if (responses.length === 0) {
    return { skipped: true, reason: 'no_responses' };
  }

  // Combine all responses and extract
  const combinedText = responses.join('\n\n---\n\n');
  const extraction = extractKnowledge(combinedText, {
    debug: process.env.GSD_DEBUG
  });

  if (extraction.extractions.length === 0) {
    return {
      skipped: true,
      reason: 'no_extractions',
      stats: {
        responses_analyzed: responses.length,
        raw_matches: extraction.total_raw,
        filtered: extraction.total_filtered
      }
    };
  }

  // Process extractions (defer to evolution module if available)
  let processResult = { created: 0, evolved: 0, skipped: 0 };

  try {
    const { processExtractionBatch } = require('../knowledge-evolution.js');
    const { knowledge } = require('../knowledge.js');

    if (knowledge.isReady(config.scope)) {
      // Get connection and process
      const conn = await knowledge._getConnection(config.scope);
      processResult = await processExtractionBatch(conn, extraction.extractions, {
        scope: config.scope,
        source: 'session_end_hook'
      });
    }
  } catch (err) {
    console.warn('[session-end] Processing failed:', err.message);
    processResult.error = err.message;
  }

  // Clear history after processing
  clearConversationHistory();

  return {
    success: true,
    stats: {
      responses_analyzed: responses.length,
      raw_matches: extraction.total_raw,
      filtered: extraction.total_filtered,
      deduplicated: extraction.total_deduplicated,
      ...processResult
    }
  };
}
```

**Register process hooks:**
```javascript
let registered = false;

function registerSessionEndHook() {
  if (registered) return;

  // Handle graceful shutdown
  const signals = ['beforeExit', 'SIGTERM', 'SIGINT'];
  const handler = async (signal) => {
    console.log(`[session-end] Processing on ${signal}...`);
    try {
      const result = await sessionEndHook();
      if (!result.skipped) {
        console.log(`[session-end] Extracted: ${result.stats.deduplicated} items`);
        console.log(`[session-end] Created: ${result.stats.created}, Evolved: ${result.stats.evolved}, Skipped: ${result.stats.skipped}`);
      }
    } catch (err) {
      console.warn('[session-end] Error:', err.message);
    }
  };

  for (const sig of signals) {
    if (sig === 'beforeExit') {
      process.on(sig, handler);
    } else {
      process.on(sig, () => handler(sig));
    }
  }

  registered = true;
  return { registered: true };
}
```

**Exports:**
- addToHistory(message) -> void
- getConversationHistory() -> Message[]
- clearConversationHistory() -> void
- sessionEndHook(options?) -> { success?, skipped?, stats? }
- registerSessionEndHook() -> { registered }
  </action>
  <verify>
```bash
cd get-shit-done && node -e "
const { addToHistory, getConversationHistory, sessionEndHook, clearConversationHistory } = require('./bin/hooks/session-end.js');

// Simulate conversation
addToHistory({ role: 'user', content: 'How should I store data?' });
addToHistory({ role: 'assistant', content: \"Let's use SQLite for storage. It's simple and reliable.\" });
addToHistory({ role: 'user', content: 'Any gotchas?' });
addToHistory({ role: 'assistant', content: \"The trick is to use WAL mode for better concurrency.\" });

console.log('History length:', getConversationHistory().length);

// Run extraction (without DB, will fail gracefully)
(async () => {
  const result = await sessionEndHook();
  console.log('Result:', result);
  clearConversationHistory();
  console.log('Cleared, history:', getConversationHistory().length);
})();
"
```
  </verify>
  <done>
- addToHistory accumulates conversation messages
- sessionEndHook extracts from all assistant responses
- Process signals (SIGTERM, SIGINT, beforeExit) trigger extraction
- History cleared after processing
  </done>
</task>

<task type="auto">
  <name>Task 3: Create per-turn hook</name>
  <files>get-shit-done/bin/hooks/per-turn.js</files>
  <action>
Create `get-shit-done/bin/hooks/per-turn.js` (HOOK-05):

**Per-turn extraction:**
```javascript
const { loadHookConfig } = require('./config.js');
const { extractKnowledge } = require('../knowledge-extraction.js');

// Track processed responses to avoid re-extraction
const processedResponses = new Set();

function hashResponse(content) {
  const crypto = require('crypto');
  return crypto.createHash('md5').update(content).digest('hex');
}

async function perTurnHook(response, options = {}) {
  const config = loadHookConfig(options);

  if (!config.enabled || config.timing !== 'per-turn') {
    return { skipped: true, reason: 'disabled_or_wrong_timing' };
  }

  if (!response || typeof response !== 'string') {
    return { skipped: true, reason: 'invalid_response' };
  }

  // Skip if already processed
  const hash = hashResponse(response);
  if (processedResponses.has(hash)) {
    return { skipped: true, reason: 'already_processed' };
  }
  processedResponses.add(hash);

  // Extract from this response
  const extraction = extractKnowledge(response, {
    debug: process.env.GSD_DEBUG
  });

  if (extraction.extractions.length === 0) {
    return {
      skipped: true,
      reason: 'no_extractions',
      stats: {
        raw_matches: extraction.total_raw,
        filtered: extraction.total_filtered
      }
    };
  }

  // Process immediately (async, non-blocking intent)
  let processResult = { created: 0, evolved: 0, skipped: 0 };

  try {
    const { processExtractionBatch } = require('../knowledge-evolution.js');
    const { knowledge } = require('../knowledge.js');

    if (knowledge.isReady(config.scope)) {
      const conn = await knowledge._getConnection(config.scope);
      processResult = await processExtractionBatch(conn, extraction.extractions, {
        scope: config.scope,
        source: 'per_turn_hook'
      });
    }
  } catch (err) {
    // Non-blocking: log and continue
    if (process.env.GSD_DEBUG) {
      console.warn('[per-turn] Processing failed:', err.message);
    }
    processResult.error = err.message;
  }

  return {
    success: true,
    stats: {
      raw_matches: extraction.total_raw,
      filtered: extraction.total_filtered,
      deduplicated: extraction.total_deduplicated,
      ...processResult
    }
  };
}
```

**Middleware pattern for integration:**
```javascript
function createPerTurnMiddleware(options = {}) {
  return async function perTurnMiddleware(context, next) {
    // Call next handler first
    const result = await next(context);

    // Extract from Claude's response (non-blocking)
    if (context.response) {
      perTurnHook(context.response, options).catch(err => {
        console.warn('[per-turn] Hook error:', err.message);
      });
    }

    return result;
  };
}

// Simple async wrapper for direct use
async function extractFromResponse(response, options = {}) {
  return perTurnHook(response, options);
}
```

**Clear tracking (for testing):**
```javascript
function clearProcessedResponses() {
  processedResponses.clear();
}
```

**Exports:**
- perTurnHook(response, options?) -> { success?, skipped?, stats? }
- createPerTurnMiddleware(options?) -> middleware function
- extractFromResponse(response, options?) -> Promise<result>
- clearProcessedResponses() -> void
  </action>
  <verify>
```bash
cd get-shit-done && node -e "
const { perTurnHook, clearProcessedResponses } = require('./bin/hooks/per-turn.js');
const { setHooksTiming } = require('./bin/hooks/config.js');

// Enable per-turn mode
setHooksTiming('per-turn');

(async () => {
  // Test extraction
  const response = \"Let's use better-sqlite3 for the database. The trick is to enable WAL mode.\";

  const result1 = await perTurnHook(response);
  console.log('First call:', result1);

  // Same response should be skipped
  const result2 = await perTurnHook(response);
  console.log('Second call:', result2);

  // Clear and retry
  clearProcessedResponses();
  const result3 = await perTurnHook(response);
  console.log('After clear:', result3);

  // Reset to session-end
  setHooksTiming('session-end');
})();
"
```
  </verify>
  <done>
- perTurnHook extracts from single response
- Tracks processed responses to avoid duplicates
- Non-blocking error handling (logs and continues)
- createPerTurnMiddleware provides integration pattern
  </done>
</task>

</tasks>

<verification>
All hook integration tests pass:
- Configuration loads/saves correctly
- setHooksEnabled toggles hook state
- setHooksTiming switches between 'session-end' and 'per-turn'
- Session-end hook processes accumulated history
- Per-turn hook processes single responses
- Both hooks skip when disabled or wrong timing mode
</verification>

<success_criteria>
1. loadHookConfig returns merged config with defaults
2. setHooksEnabled(true/false) enables/disables extraction
3. setHooksTiming('per-turn'/'session-end') switches modes
4. sessionEndHook batches extraction at session end
5. perTurnHook extracts from single response
6. Both hooks skip when disabled (HOOK-07)
7. Timing mode respected (HOOK-05, HOOK-06, HOOK-08)
</success_criteria>

<output>
After completion, create `.planning/phases/04-knowledge-extraction-hooks/04-04-SUMMARY.md`
</output>
