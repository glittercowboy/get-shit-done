---
phase: 04-knowledge-extraction-hooks
plan: 06
type: execute
wave: 3
depends_on: ["04-03"]
files_modified:
  - get-shit-done/bin/knowledge-synthesis.js
  - get-shit-done/bin/knowledge-principles.js
autonomous: true

must_haves:
  truths:
    - "Synthesis consolidates related knowledge into principles"
    - "Principles require minimum evidence (5+ examples)"
    - "Principles have confidence scores"
    - "Claude can check principles before making decisions"
    - "Autonomous decisions apply to reversible actions only"
  artifacts:
    - path: "get-shit-done/bin/knowledge-synthesis.js"
      provides: "Knowledge synthesis into principles"
      exports: ["synthesizePrinciples", "clusterKnowledge", "extractPrinciple"]
    - path: "get-shit-done/bin/knowledge-principles.js"
      provides: "Principle-based decision making"
      exports: ["checkPrinciples", "applyPrinciple", "canActAutonomously"]
  key_links:
    - from: "get-shit-done/bin/knowledge-synthesis.js"
      to: "get-shit-done/bin/knowledge-search.js"
      via: "search for clustering"
      pattern: "searchKnowledge|hybridSearch"
    - from: "get-shit-done/bin/knowledge-principles.js"
      to: "get-shit-done/bin/knowledge.js"
      via: "knowledge lookup"
      pattern: "knowledge\\.search|knowledge\\.get"
---

<objective>
Implement synthesis passes that consolidate knowledge into principles and enable autonomous decision-making

Purpose: Extract higher-level reasoning patterns (KNOW-15, KNOW-18) and enable autonomous decisions (KNOW-19)
Output: knowledge-synthesis.js for principle extraction, knowledge-principles.js for autonomous behavior
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-knowledge-extraction-hooks/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create knowledge synthesis module</name>
  <files>get-shit-done/bin/knowledge-synthesis.js</files>
  <action>
Create `get-shit-done/bin/knowledge-synthesis.js` implementing KNOW-15 and KNOW-18:

**Synthesis thresholds:**
```javascript
const SYNTHESIS_CONFIG = {
  min_cluster_size: 5,       // Minimum examples to form principle
  confidence_threshold: 0.7, // Minimum confidence for valid principle
  similarity_threshold: 0.6, // Similarity for clustering
  max_principles: 20,        // Limit principles per synthesis run
  stale_days: 30             // Refresh synthesis after N days
};
```

**Knowledge clustering by topic:**
```javascript
const { knowledge } = require('./knowledge.js');
const { generateEmbedding } = require('./embeddings.js');

// Simple clustering based on embedding similarity
async function clusterKnowledge(conn, options = {}) {
  const { types = ['decision', 'lesson'], limit = 100 } = options;
  const { db } = conn;

  // Get recent knowledge entries
  const entries = db.prepare(`
    SELECT id, content, type, metadata, created_at
    FROM knowledge
    WHERE type IN (${types.map(() => '?').join(',')})
      AND (expires_at IS NULL OR expires_at > ?)
    ORDER BY created_at DESC
    LIMIT ?
  `).all(...types, Date.now(), limit);

  if (entries.length < SYNTHESIS_CONFIG.min_cluster_size) {
    return { clusters: [], reason: 'insufficient_knowledge' };
  }

  // Generate embeddings for all entries
  const embeddings = new Map();
  for (const entry of entries) {
    const emb = await generateEmbedding(entry.content);
    if (emb) embeddings.set(entry.id, emb);
  }

  // Simple greedy clustering
  const clusters = [];
  const assigned = new Set();

  for (const entry of entries) {
    if (assigned.has(entry.id)) continue;

    const embedding = embeddings.get(entry.id);
    if (!embedding) continue;

    // Start new cluster
    const cluster = {
      seed: entry,
      members: [entry],
      embeddings: [embedding]
    };
    assigned.add(entry.id);

    // Find similar entries
    for (const other of entries) {
      if (assigned.has(other.id)) continue;

      const otherEmb = embeddings.get(other.id);
      if (!otherEmb) continue;

      // Calculate cosine similarity
      const similarity = cosineSimilarity(embedding, otherEmb);

      if (similarity >= SYNTHESIS_CONFIG.similarity_threshold) {
        cluster.members.push(other);
        cluster.embeddings.push(otherEmb);
        assigned.add(other.id);
      }
    }

    // Only keep clusters meeting minimum size
    if (cluster.members.length >= SYNTHESIS_CONFIG.min_cluster_size) {
      cluster.topic = inferTopic(cluster.members);
      cluster.size = cluster.members.length;
      clusters.push(cluster);
    }
  }

  return { clusters };
}

// Cosine similarity between two embeddings
function cosineSimilarity(a, b) {
  let dot = 0, normA = 0, normB = 0;
  for (let i = 0; i < a.length; i++) {
    dot += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }
  return dot / (Math.sqrt(normA) * Math.sqrt(normB));
}

// Infer topic from cluster members (simple keyword extraction)
function inferTopic(members) {
  const words = {};
  for (const m of members) {
    const tokens = m.content.toLowerCase()
      .replace(/[^\w\s]/g, '')
      .split(/\s+/)
      .filter(w => w.length > 3);

    for (const token of tokens) {
      words[token] = (words[token] || 0) + 1;
    }
  }

  // Get top 3 most common words
  const sorted = Object.entries(words)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([w]) => w);

  return sorted.join('_') || 'general';
}
```

**Extract principle from cluster:**
```javascript
function extractPrinciple(cluster) {
  const { members, topic } = cluster;

  // Find common patterns in member content
  const patterns = members.map(m => m.content);

  // Calculate confidence based on cluster cohesion
  // More members + more similar = higher confidence
  const avgSimilarity = calculateAverageSimilarity(cluster.embeddings);
  const sizeBonus = Math.min(members.length / 10, 0.2);  // Max 0.2 bonus
  const confidence = Math.min(avgSimilarity + sizeBonus, 1.0);

  // Generate principle text (simplified - real would use LLM)
  const principleText = generatePrincipleText(patterns, topic);

  return {
    topic,
    rule: principleText,
    confidence,
    examples: patterns.slice(0, 5),  // Store up to 5 examples
    source_count: members.length,
    source_ids: members.map(m => m.id),
    created_at: Date.now()
  };
}

function calculateAverageSimilarity(embeddings) {
  if (embeddings.length < 2) return 1.0;

  let totalSim = 0, pairs = 0;
  for (let i = 0; i < embeddings.length; i++) {
    for (let j = i + 1; j < embeddings.length; j++) {
      totalSim += cosineSimilarity(embeddings[i], embeddings[j]);
      pairs++;
    }
  }

  return pairs > 0 ? totalSim / pairs : 0;
}

function generatePrincipleText(patterns, topic) {
  // Extract common phrases (simplified)
  // Real implementation would use LLM to synthesize
  const words = patterns[0].split(' ').slice(0, 10).join(' ');
  return `For ${topic.replace(/_/g, ' ')}: ${words}...`;
}
```

**Full synthesis pass:**
```javascript
async function synthesizePrinciples(conn, options = {}) {
  const { db } = conn;

  // Get clusters
  const { clusters, reason } = await clusterKnowledge(conn, options);

  if (reason) {
    return { synthesized: 0, reason };
  }

  const principles = [];

  for (const cluster of clusters.slice(0, SYNTHESIS_CONFIG.max_principles)) {
    const principle = extractPrinciple(cluster);

    // Only store if confidence meets threshold
    if (principle.confidence >= SYNTHESIS_CONFIG.confidence_threshold) {
      // Store as 'principle' type knowledge
      const { insertOrEvolve } = require('./knowledge-evolution.js');
      const embedding = await generateEmbedding(principle.rule);

      const result = await insertOrEvolve(conn, {
        content: principle.rule,
        type: 'principle',
        scope: 'global',  // Principles are global
        embedding,
        metadata: {
          topic: principle.topic,
          confidence: principle.confidence,
          examples: principle.examples,
          source_count: principle.source_count,
          source_ids: principle.source_ids,
          synthesized_at: Date.now()
        }
      });

      principles.push({
        ...principle,
        action: result.action,
        id: result.id
      });
    }
  }

  return {
    synthesized: principles.length,
    clusters_found: clusters.length,
    principles
  };
}
```

**Exports:**
- SYNTHESIS_CONFIG
- clusterKnowledge(conn, options?) -> { clusters }
- extractPrinciple(cluster) -> principle
- cosineSimilarity(a, b) -> number
- synthesizePrinciples(conn, options?) -> { synthesized, principles }
  </action>
  <verify>
```bash
cd get-shit-done && node -e "
const { SYNTHESIS_CONFIG, cosineSimilarity } = require('./bin/knowledge-synthesis.js');

console.log('Synthesis config:', SYNTHESIS_CONFIG);

// Test cosine similarity
const a = new Float32Array([1, 0, 0, 0]);
const b = new Float32Array([1, 0, 0, 0]);
const c = new Float32Array([0, 1, 0, 0]);

console.log('Same vectors:', cosineSimilarity(a, b));    // Should be 1.0
console.log('Orthogonal:', cosineSimilarity(a, c));       // Should be 0.0
"
```
  </verify>
  <done>
- clusterKnowledge groups similar entries by embedding
- extractPrinciple generates principles from clusters
- Minimum 5 examples required for principle
- Confidence score based on cluster cohesion
- synthesizePrinciples stores principles in knowledge base
  </done>
</task>

<task type="auto">
  <name>Task 2: Create principle-based decision module</name>
  <files>get-shit-done/bin/knowledge-principles.js</files>
  <action>
Create `get-shit-done/bin/knowledge-principles.js` implementing KNOW-19:

**Decision context and principle lookup:**
```javascript
const { knowledge } = require('./knowledge.js');
const { generateEmbedding } = require('./embeddings.js');

// Action classification for autonomy
const ACTION_TYPES = {
  reversible: [
    'create_file', 'edit_file', 'add_code', 'update_code',
    'install_package', 'run_test', 'format_code', 'lint'
  ],
  irreversible: [
    'delete_file', 'delete_directory', 'drop_table',
    'remove_package', 'git_push_force', 'production_deploy'
  ],
  external: [
    'send_email', 'api_call', 'notification', 'webhook'
  ],
  costly: [
    'cloud_resource', 'paid_api', 'large_compute'
  ]
};

// Check relevant principles for a decision context
async function checkPrinciples(context, options = {}) {
  const { scope = 'global', limit = 5 } = options;

  try {
    // Search for relevant principles
    const embedding = await generateEmbedding(context);
    const results = await knowledge.search(context, {
      scope,
      types: ['principle'],
      limit,
      embedding  // Use embedding for better matching
    });

    // Filter by confidence
    const applicable = results.filter(r => {
      const meta = r.metadata || {};
      return meta.confidence >= 0.7;  // Only high-confidence principles
    });

    return {
      found: applicable.length > 0,
      principles: applicable.map(p => ({
        id: p.id,
        rule: p.content,
        confidence: p.metadata?.confidence || 0,
        topic: p.metadata?.topic
      }))
    };
  } catch (err) {
    return { found: false, error: err.message };
  }
}
```

**Autonomy decision logic:**
```javascript
function classifyAction(action) {
  const lowerAction = action.toLowerCase();

  for (const [category, keywords] of Object.entries(ACTION_TYPES)) {
    for (const keyword of keywords) {
      if (lowerAction.includes(keyword.replace(/_/g, ' ')) ||
          lowerAction.includes(keyword)) {
        return { category, keyword };
      }
    }
  }

  return { category: 'reversible', keyword: 'default' };
}

async function canActAutonomously(action, context = '', options = {}) {
  // Step 1: Classify action type
  const classification = classifyAction(action);

  // Irreversible, external, or costly actions require human approval
  if (classification.category !== 'reversible') {
    return {
      autonomous: false,
      reason: `${classification.category}_action`,
      category: classification.category,
      requires_approval: true
    };
  }

  // Step 2: Check for relevant principles
  const principleCheck = await checkPrinciples(
    `${action}: ${context}`,
    options
  );

  if (principleCheck.found && principleCheck.principles.length > 0) {
    // Have guiding principles - can act autonomously
    const topPrinciple = principleCheck.principles[0];

    return {
      autonomous: true,
      reason: 'principle_guided',
      principle: topPrinciple.rule,
      confidence: topPrinciple.confidence,
      principle_id: topPrinciple.id
    };
  }

  // Step 3: No principles but reversible - cautious autonomy
  return {
    autonomous: true,
    reason: 'reversible_default',
    confidence: 0.5,  // Lower confidence without principle
    note: 'No matching principles, proceeding with caution'
  };
}
```

**Apply principle to decision:**
```javascript
async function applyPrinciple(principleId, action, outcome, options = {}) {
  const { scope = 'global' } = options;

  try {
    // Get the principle
    const principle = await knowledge.get(principleId, scope);
    if (!principle) {
      return { applied: false, reason: 'principle_not_found' };
    }

    // Track principle usage
    const { updateKnowledge } = require('./knowledge-crud.js');
    const conn = await knowledge._getConnection(scope);

    const meta = principle.metadata || {};
    await updateKnowledge(conn.db, principleId, {
      metadata: {
        ...meta,
        usage_count: (meta.usage_count || 0) + 1,
        last_used: Date.now(),
        last_action: action,
        last_outcome: outcome
      }
    });

    return {
      applied: true,
      principle: principle.content,
      usage_count: (meta.usage_count || 0) + 1
    };
  } catch (err) {
    return { applied: false, reason: err.message };
  }
}
```

**Decision helper for Claude:**
```javascript
async function makeDecision(action, context, options = {}) {
  // Full decision flow
  const autonomyCheck = await canActAutonomously(action, context, options);

  const decision = {
    action,
    context,
    can_proceed: autonomyCheck.autonomous,
    ...autonomyCheck
  };

  if (!autonomyCheck.autonomous) {
    decision.message = `This ${autonomyCheck.category} action requires human approval.`;
    decision.prompt = `Should I proceed with: ${action}?`;
  } else if (autonomyCheck.principle) {
    decision.message = `Proceeding based on learned principle: ${autonomyCheck.principle}`;
  } else {
    decision.message = 'Proceeding with reversible action (no specific principle applies).';
  }

  return decision;
}
```

**Exports:**
- ACTION_TYPES
- classifyAction(action) -> { category, keyword }
- checkPrinciples(context, options?) -> { found, principles }
- canActAutonomously(action, context?, options?) -> { autonomous, reason, ... }
- applyPrinciple(principleId, action, outcome, options?) -> { applied, ... }
- makeDecision(action, context, options?) -> decision
  </action>
  <verify>
```bash
cd get-shit-done && node -e "
const { classifyAction, canActAutonomously, ACTION_TYPES } = require('./bin/knowledge-principles.js');

// Test action classification
console.log('Action types:', Object.keys(ACTION_TYPES));

console.log('\\nClassifications:');
console.log('create_file:', classifyAction('create_file'));
console.log('delete database:', classifyAction('delete database'));
console.log('send email:', classifyAction('send email notification'));
console.log('add test:', classifyAction('add test'));

// Test autonomy check
(async () => {
  console.log('\\nAutonomy checks:');

  const create = await canActAutonomously('create file', 'new component');
  console.log('create file:', create.autonomous, create.reason);

  const del = await canActAutonomously('delete production data', '');
  console.log('delete production:', del.autonomous, del.reason);

  const email = await canActAutonomously('send email to user', '');
  console.log('send email:', email.autonomous, email.reason);
})();
"
```
  </verify>
  <done>
- classifyAction categorizes actions (reversible/irreversible/external/costly)
- checkPrinciples finds relevant principles for context
- canActAutonomously returns true only for reversible actions
- Irreversible/external/costly require human approval
- Principle-guided decisions have higher confidence
  </done>
</task>

</tasks>

<verification>
All synthesis and autonomy tests pass:
- Knowledge clustered by embedding similarity
- Principles extracted from clusters with 5+ members
- Confidence scores based on cluster cohesion
- Reversible actions can proceed autonomously
- Irreversible/external/costly actions require approval
- Principle lookup guides autonomous decisions
</verification>

<success_criteria>
1. clusterKnowledge groups similar knowledge entries
2. Principles require minimum 5 examples (KNOW-18)
3. Principles have confidence scores >= 0.7
4. synthesizePrinciples stores principles in knowledge base
5. classifyAction identifies action categories
6. canActAutonomously returns true for reversible actions only
7. Irreversible/external/costly require human approval
8. checkPrinciples finds relevant guiding principles
</success_criteria>

<output>
After completion, create `.planning/phases/04-knowledge-extraction-hooks/04-06-SUMMARY.md`
</output>
