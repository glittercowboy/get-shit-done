---
phase: 06-autonomous-execution-core
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - get-shit-done/workflows/execute-roadmap.md
  - get-shit-done/agents/gsd-phase-coordinator.md
  - commands/gsd/execute-roadmap.md
  - get-shit-done/bin/gsd-tools.js
autonomous: true

must_haves:
  truths:
    - "User can run /gsd:execute-roadmap and see execution confirmation"
    - "Coordinator parses roadmap and presents execution plan"
    - "Each phase spawns with fresh context window"
    - "Sub-coordinator executes full cycle (research, plan, execute, verify)"
  artifacts:
    - path: "get-shit-done/workflows/execute-roadmap.md"
      provides: "Roadmap orchestration workflow"
      min_lines: 150
    - path: "get-shit-done/agents/gsd-phase-coordinator.md"
      provides: "Phase sub-coordinator agent"
      min_lines: 80
    - path: "commands/gsd/execute-roadmap.md"
      provides: "Slash command entry point"
      min_lines: 10
  key_links:
    - from: "execute-roadmap.md"
      to: "gsd-phase-coordinator.md"
      via: "Task spawning"
      pattern: "subagent_type.*gsd-phase-coordinator"
    - from: "execute-roadmap.md"
      to: "roadmap-parser.js"
      via: "gsd-tools roadmap commands"
      pattern: "gsd-tools.js roadmap"
---

<objective>
Create the execute-roadmap workflow and phase coordinator agent.

Purpose: Enable autonomous multi-phase roadmap execution with Opus coordinator spawning fresh sub-coordinators per phase.
Output: execute-roadmap.md workflow, gsd-phase-coordinator.md agent, /gsd:execute-roadmap command.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-autonomous-execution-core/06-RESEARCH.md
@.planning/phases/06-autonomous-execution-core/06-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create execute-roadmap workflow</name>
  <files>get-shit-done/workflows/execute-roadmap.md</files>
  <action>
Create execute-roadmap.md workflow following execute-phase.md patterns:

**Structure:**
```markdown
<purpose>
Execute entire ROADMAP.md autonomously with Opus coordinator spawning sub-coordinators per phase.
</purpose>

<core_principle>
Coordinator stays lean â€” parses roadmap, tracks DAG, spawns phases. Each phase gets fresh 200k context. No context rot across multi-phase execution.
</core_principle>

<process>

<step name="initialize" priority="first">
Load roadmap context:
- Check .planning/ROADMAP.md exists (EXEC-01)
- Parse roadmap via: `gsd-tools.js roadmap parse`
- Build DAG via: `gsd-tools.js roadmap dag`
- Get execution order and parallel opportunities
</step>

<step name="confirm_execution">
Present execution plan to user (EXEC-02):
- Total phases, execution order
- Estimated duration (based on phase complexity)
- Dependencies visualization
- "Confirm autonomous execution? (yes/no)"
If no: exit. If yes: continue.
</step>

<step name="initialize_execution_log">
Create/append to .planning/EXECUTION_LOG.md:
- Log roadmap_start event
- Include: total phases, execution order, timestamp
</step>

<step name="execute_phases">
For each phase in execution order (EXEC-04, EXEC-06):

1. **Check dependencies:**
   - Use `gsd-tools.js roadmap status {dep}` for each dependency
   - If any not complete: wait/error

2. **Spawn sub-coordinator (fresh context):**
   ```
   Task(
     subagent_type="gsd-phase-coordinator",
     model="opus",
     prompt="Execute Phase {N}: {name}

     Full cycle: research -> plan -> execute -> verify

     @workflows/execute-phase-lifecycle.md

     Create checkpoint after each step.
     Return structured completion state."
   )
   ```

3. **Handle result:**
   - Success: log phase_complete, continue
   - Failure: create checkpoint, ask user (retry/skip/stop)
   - Blocked: present blocker, wait for resolution

4. **Archive phase context** (EXEC-07):
   - Compress completed phase to summary
   - Clean up ephemeral checkpoints
</step>

<step name="handle_failure">
On phase failure:
- Create detailed checkpoint
- Log failure to EXECUTION_LOG.md
- Present options: Retry | Skip | Stop
- Store failure context for manual intervention
</step>

<step name="resume_capability">
If previous execution incomplete (EXEC-10):
- Find last completed phase from EXECUTION_LOG.md
- Search for incomplete checkpoints
- Present resume context to user
- Continue from next incomplete phase
</step>

<step name="completion">
After all phases:
- Log roadmap_complete event
- Present completion summary
- Clean up ephemeral checkpoints
</step>

</process>
```

Include sections for context_efficiency, failure_handling, resumption (matching execute-phase.md patterns).
  </action>
  <verify>
```bash
# Verify workflow exists and has required sections
grep -c "<step name=" /Users/ollorin/.claude/get-shit-done/workflows/execute-roadmap.md
# Should be 7+ steps

grep "subagent_type.*gsd-phase-coordinator" /Users/ollorin/.claude/get-shit-done/workflows/execute-roadmap.md
# Should find the Task spawn
```
  </verify>
  <done>execute-roadmap.md workflow exists with initialize, confirm_execution, execute_phases, handle_failure, resume_capability, completion steps</done>
</task>

<task type="auto">
  <name>Task 2: Create gsd-phase-coordinator agent</name>
  <files>get-shit-done/agents/gsd-phase-coordinator.md</files>
  <action>
Create gsd-phase-coordinator.md agent definition:

**Structure:**
```markdown
---
name: gsd-phase-coordinator
description: Executes full phase lifecycle (research, plan, execute, verify) with checkpoints
tools: Read, Write, Bash, Glob, Grep, WebFetch, Task
color: blue
---

<role>
You are a phase coordinator. You execute the full lifecycle of a single phase: research -> plan -> execute -> verify. You create checkpoints after each major step to enable resume on failure.

Spawned by: execute-roadmap.md coordinator

Your job: Complete the phase cycle autonomously, returning structured state for the parent coordinator.
</role>

<execution_cycle>

<step name="research">
If phase needs research (no RESEARCH.md exists):
- Run /gsd:research-phase {phase}
- Create checkpoint: { step: "research", status: "complete" }
If RESEARCH.md exists: skip, create checkpoint with status: "skipped"
</step>

<step name="plan">
If phase needs planning (no PLAN.md files):
- Run /gsd:plan-phase {phase}
- Create checkpoint: { step: "plan", status: "complete" }
If plans exist: skip with checkpoint
</step>

<step name="execute">
Execute all plans in phase:
- Run execute-phase workflow internally
- Create checkpoint after each wave completion
- Handle failures: create checkpoint, return failure state
</step>

<step name="verify">
Verify phase goal achieved:
- Run /gsd:verify-work {phase}
- If passed: return success state
- If gaps: return gaps_found state with details
- If human_needed: return human_needed state
</step>

</execution_cycle>

<checkpoint_protocol>
After each step (research, plan, execute, verify):
- Store checkpoint via gsd-tools
- Include: phase, step, status, files_touched, key_context
- Enable resume from this point on failure
</checkpoint_protocol>

<return_state>
Return structured JSON:
{
  phase: number,
  status: "completed" | "failed" | "blocked" | "gaps_found" | "human_needed",
  checkpoints: [...],
  files_modified: [...],
  error?: string,
  gaps?: [...],
  human_items?: [...]
}
</return_state>
```

Include sections for: role, execution_cycle (4 steps), checkpoint_protocol, return_state, error_handling.
  </action>
  <verify>
```bash
# Verify agent exists with required structure
grep -c "<step name=" /Users/ollorin/.claude/get-shit-done/agents/gsd-phase-coordinator.md
# Should be 4 steps (research, plan, execute, verify)

grep "subagent_type\|status.*completed\|checkpoint" /Users/ollorin/.claude/get-shit-done/agents/gsd-phase-coordinator.md | head -5
```
  </verify>
  <done>gsd-phase-coordinator.md agent exists with research, plan, execute, verify lifecycle and checkpoint protocol</done>
</task>

<task type="auto">
  <name>Task 3: Create slash command and init integration</name>
  <files>
    commands/gsd/execute-roadmap.md
    get-shit-done/bin/gsd-tools.js
  </files>
  <action>
**1. Create slash command (commands/gsd/execute-roadmap.md):**
```markdown
---
name: execute-roadmap
description: Execute entire roadmap autonomously with checkpoints
---

<purpose>
Autonomous multi-phase roadmap execution with Opus coordinator.
</purpose>

<workflow>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-roadmap.md
</workflow>
```

**2. Add init command to gsd-tools.js:**

Add `init execute-roadmap` subcommand:

```javascript
case 'execute-roadmap': {
  // Check ROADMAP.md exists
  const roadmapPath = path.join(process.cwd(), '.planning/ROADMAP.md');
  if (!fs.existsSync(roadmapPath)) {
    console.log(JSON.stringify({ error: 'ROADMAP.md not found', roadmap_exists: false }));
    break;
  }

  // Parse roadmap
  const { parseRoadmap, getExecutionOrder, getNextExecutablePhases } = require('./roadmap-parser.js');
  const roadmap = await parseRoadmap(roadmapPath);
  const order = getExecutionOrder(roadmap.phases);
  const executable = getNextExecutablePhases(roadmap.phases);

  // Check for existing execution log
  const executionLogPath = path.join(process.cwd(), '.planning/EXECUTION_LOG.md');
  const hasExecutionLog = fs.existsSync(executionLogPath);

  // Check for incomplete execution (resume capability)
  let resumeState = null;
  if (hasExecutionLog) {
    // Parse log for last completed phase
    const logContent = fs.readFileSync(executionLogPath, 'utf-8');
    const lines = logContent.split('\n').filter(l => l.trim());
    const events = lines.slice(1).map(l => {
      try { return JSON.parse(l); } catch { return null; }
    }).filter(Boolean);

    const lastComplete = events.filter(e => e.type === 'phase_complete').pop();
    const lastStart = events.filter(e => e.type === 'phase_start').pop();

    if (lastStart && (!lastComplete || lastStart.phase > lastComplete.phase)) {
      resumeState = { phase: lastStart.phase, status: 'in_progress' };
    }
  }

  console.log(JSON.stringify({
    roadmap_exists: true,
    total_phases: roadmap.total,
    execution_order: order.execution_order,
    parallel_opportunities: order.parallel_opportunities || [],
    next_executable: executable.executable,
    blocked_phases: executable.blocked,
    has_execution_log: hasExecutionLog,
    resume_state: resumeState,
    coordinator_model: 'opus'
  }));
  break;
}
```

This provides all context needed for execute-roadmap workflow initialization.
  </action>
  <verify>
```bash
# Verify slash command exists
cat /Users/ollorin/.claude/commands/gsd/execute-roadmap.md

# Test init command
node /Users/ollorin/.claude/get-shit-done/bin/gsd-tools.js init execute-roadmap
```
  </verify>
  <done>Slash command exists at commands/gsd/execute-roadmap.md, gsd-tools.js responds to "init execute-roadmap"</done>
</task>

</tasks>

<verification>
- execute-roadmap.md workflow exists in get-shit-done/workflows/
- gsd-phase-coordinator.md agent exists in get-shit-done/agents/
- Slash command exists at commands/gsd/execute-roadmap.md
- `gsd-tools.js init execute-roadmap` returns roadmap metadata
- Workflow includes confirmation step before execution
- Workflow spawns sub-coordinators with fresh context
</verification>

<success_criteria>
- /gsd:execute-roadmap command is recognized
- Workflow checks for ROADMAP.md before proceeding
- User confirmation required before autonomous execution
- Sub-coordinator agent defined with full lifecycle
- Fresh context per phase (Task spawning, not resume)
</success_criteria>

<output>
After completion, create `.planning/phases/06-autonomous-execution-core/06-02-SUMMARY.md`
</output>
