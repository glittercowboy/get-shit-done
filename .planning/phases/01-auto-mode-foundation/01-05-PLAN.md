---
phase: 01-auto-mode-foundation
plan: 05
type: execute
wave: 3
depends_on: [01-01]
files_modified:
  - ~/.claude/routing-rules.md
  - .planning/routing/project-rules.md
  - .planning/routing/routing-stats.jsonl
autonomous: false

must_haves:
  truths:
    - "Session logs from igaming-platform scanned for patterns"
    - "Routing rules generated from real usage patterns"
    - "User reviews and approves rules before finalization"
  artifacts:
    - path: "~/.claude/routing-rules.md"
      provides: "Enhanced global rules from session analysis"
      contains: "Pattern | Model | Priority | Evidence"
    - path: ".planning/routing/project-rules.md"
      provides: "Project-specific rules from usage patterns"
      contains: "Pattern | Model | Priority"
  key_links:
    - from: "routing-rules.md"
      to: "session logs"
      via: "pattern extraction"
      pattern: "extracted from.*sessions"
---

<objective>
Scan igaming-platform project sessions to bootstrap initial routing rules from real usage patterns.

Purpose: Generate evidence-based routing rules rather than guessing patterns.
Output: Enhanced routing rules with real usage evidence, reviewed and approved by user.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auto-mode-foundation/01-CONTEXT.md
@.planning/phases/01-auto-mode-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Explore session log format and locations</name>
  <files>N/A (exploration)</files>
  <action>
Investigate Claude Code session storage to understand log format:

1. Check igaming-platform project sessions location:
   ```bash
   ls -la ~/.claude/projects/ | head -20
   ```

2. Find the igaming-platform project hash:
   ```bash
   # Look for project entries that might be igaming-platform
   ls ~/.claude/projects/ | while read hash; do
     if [ -f ~/.claude/projects/$hash/project.json ]; then
       path=$(cat ~/.claude/projects/$hash/project.json 2>/dev/null | grep -o '"path":"[^"]*"' | head -1)
       echo "$hash: $path"
     fi
   done
   ```

3. Examine session structure:
   ```bash
   # Once project hash found, explore sessions
   PROJECT_HASH="<found-hash>"
   ls ~/.claude/projects/$PROJECT_HASH/
   ls ~/.claude/projects/$PROJECT_HASH/sessions/ 2>/dev/null | head -10
   ```

4. Check session file format:
   ```bash
   # Examine a recent session file
   head -100 ~/.claude/projects/$PROJECT_HASH/sessions/<session-id>/conversation.json 2>/dev/null
   # Or check for JSONL format
   head -20 ~/.claude/projects/$PROJECT_HASH/sessions/<session-id>/*.jsonl 2>/dev/null
   ```

5. Document findings:
   - Session storage location
   - File format (JSON, JSONL, other)
   - Structure of conversation entries
   - How to identify task descriptions vs responses
   - Date/timestamp format for filtering "last 5-7 days"

If session logs not accessible or format unclear, fallback to scanning SUMMARY.md files in .planning/phases/.
  </action>
  <verify>
Output from exploration commands shows:
- Session directory location
- File format understood
- Sample entries examined
  </verify>
  <done>
Session log format documented:
- Location: [documented]
- Format: [documented]
- Entry structure: [documented]
  </done>
</task>

<task type="auto">
  <name>Task 2: Extract patterns from session logs</name>
  <files>~/.claude/get-shit-done/bin/gsd-tools.js</files>
  <action>
Add session scanning function to extract task patterns:

1. Add `routing scan-sessions <project-path>` command:
   ```javascript
   if (command === 'routing' && subCommand === 'scan-sessions') {
     const projectPath = args[2] || cwd;

     // Find project hash for the given path
     const projectsDir = path.join(HOME, '.claude', 'projects');
     let projectHash = null;

     for (const hash of fs.readdirSync(projectsDir)) {
       const projectJson = path.join(projectsDir, hash, 'project.json');
       if (fs.existsSync(projectJson)) {
         try {
           const proj = JSON.parse(fs.readFileSync(projectJson, 'utf-8'));
           if (proj.path === projectPath || projectPath.includes(proj.path)) {
             projectHash = hash;
             break;
           }
         } catch {}
       }
     }

     if (!projectHash) {
       console.log(JSON.stringify({ error: 'Project not found', path: projectPath }));
       return;
     }

     // Find sessions from last 7 days
     const sessionsDir = path.join(projectsDir, projectHash, 'sessions');
     const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
     const recentSessions = [];

     if (fs.existsSync(sessionsDir)) {
       for (const sessionId of fs.readdirSync(sessionsDir)) {
         const sessionPath = path.join(sessionsDir, sessionId);
         const stat = fs.statSync(sessionPath);
         if (stat.mtime.getTime() > sevenDaysAgo) {
           recentSessions.push({ id: sessionId, path: sessionPath, mtime: stat.mtime });
         }
       }
     }

     // Extract task patterns from sessions
     const patterns = [];
     for (const session of recentSessions) {
       // Read conversation file (adjust based on actual format discovered in Task 1)
       const convFile = path.join(session.path, 'conversation.json');
       const convJsonl = path.join(session.path, 'messages.jsonl');

       let entries = [];
       if (fs.existsSync(convFile)) {
         try {
           const conv = JSON.parse(fs.readFileSync(convFile, 'utf-8'));
           entries = conv.messages || conv.entries || [];
         } catch {}
       } else if (fs.existsSync(convJsonl)) {
         try {
           const lines = fs.readFileSync(convJsonl, 'utf-8').split('\n').filter(Boolean);
           entries = lines.map(l => JSON.parse(l));
         } catch {}
       }

       // Extract user messages that look like task requests
       for (const entry of entries) {
         const content = entry.content || entry.text || entry.message || '';
         const role = entry.role || entry.type || '';

         // Only user messages
         if (role !== 'user' && role !== 'human') continue;

         // Skip short messages
         if (content.length < 20) continue;

         // Look for task-like patterns
         const taskIndicators = [
           /^(create|add|implement|fix|update|refactor|write|build|design|test)/i,
           /(component|function|api|endpoint|database|schema|migration)/i,
           /(authentication|authorization|validation|error handling)/i
         ];

         if (taskIndicators.some(p => p.test(content))) {
           patterns.push({
             text: content.slice(0, 200), // Truncate
             session: session.id,
             date: session.mtime.toISOString().split('T')[0]
           });
         }
       }
     }

     console.log(JSON.stringify({
       project: projectPath,
       sessions_scanned: recentSessions.length,
       patterns_found: patterns.length,
       patterns: patterns.slice(0, 50) // Limit output
     }, null, 2));
   }
   ```

2. Also scan GSD SUMMARY.md files as alternative source:
   ```javascript
   if (command === 'routing' && subCommand === 'scan-summaries') {
     const phasesDir = path.join(cwd, '.planning', 'phases');
     const summaries = [];

     if (fs.existsSync(phasesDir)) {
       for (const phaseDir of fs.readdirSync(phasesDir)) {
         const phasePath = path.join(phasesDir, phaseDir);
         if (!fs.statSync(phasePath).isDirectory()) continue;

         for (const file of fs.readdirSync(phasePath)) {
           if (file.endsWith('-SUMMARY.md')) {
             const content = fs.readFileSync(path.join(phasePath, file), 'utf-8');
             // Extract task names and actions from summary
             const taskMatches = content.match(/##\s*Task\s*\d+[:\s]+([^\n]+)/gi) || [];
             const actionMatches = content.match(/<action>([^<]+)<\/action>/gi) || [];

             for (const match of [...taskMatches, ...actionMatches]) {
               summaries.push({
                 file: file,
                 text: match.replace(/<[^>]+>/g, '').trim().slice(0, 200)
               });
             }
           }
         }
       }
     }

     console.log(JSON.stringify({
       summaries_scanned: summaries.length,
       patterns: summaries
     }, null, 2));
   }
   ```
  </action>
  <verify>
Run:
1. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing scan-sessions /Users/ollorin/igaming-platform`
2. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing scan-summaries`
Shows patterns extracted from real usage
  </verify>
  <done>
Session scanning implemented:
- Finds project sessions from last 7 days
- Extracts task-like patterns from conversations
- Alternative: scans SUMMARY.md files
  </done>
</task>

<task type="auto">
  <name>Task 3: Generate routing rule suggestions</name>
  <files>~/.claude/get-shit-done/bin/gsd-tools.js</files>
  <action>
Add function to analyze patterns and suggest routing rules:

1. Add `routing suggest-rules` command:
   ```javascript
   if (command === 'routing' && subCommand === 'suggest-rules') {
     // Load existing patterns from scan results
     const patternsFile = args[2]; // JSON file from scan-sessions output
     let patterns = [];

     if (patternsFile && fs.existsSync(patternsFile)) {
       patterns = JSON.parse(fs.readFileSync(patternsFile, 'utf-8')).patterns || [];
     }

     // Analyze patterns for common keywords
     const keywordCounts = {};
     for (const p of patterns) {
       const keywords = extractKeywords(p.text);
       for (const k of keywords) {
         keywordCounts[k] = (keywordCounts[k] || 0) + 1;
       }
     }

     // Sort by frequency
     const topKeywords = Object.entries(keywordCounts)
       .sort((a, b) => b[1] - a[1])
       .slice(0, 30);

     // Suggest model based on keyword complexity heuristics
     const suggestions = [];
     const complexityIndicators = {
       opus: ['architecture', 'design', 'integration', 'planning', 'strategy', 'security', 'audit'],
       sonnet: ['database', 'api', 'authentication', 'migration', 'refactor', 'middleware', 'validation'],
       haiku: ['test', 'style', 'format', 'typo', 'rename', 'comment', 'log', 'button', 'css']
     };

     for (const [keyword, count] of topKeywords) {
       let model = 'sonnet'; // default
       let reason = 'common task pattern';

       for (const [tier, indicators] of Object.entries(complexityIndicators)) {
         if (indicators.some(ind => keyword.includes(ind) || ind.includes(keyword))) {
           model = tier;
           reason = `matches ${tier} complexity indicator`;
           break;
         }
       }

       suggestions.push({
         pattern: keyword,
         model,
         priority: model === 'opus' ? 3 : model === 'sonnet' ? 2 : 1,
         evidence: `Found ${count} times in sessions`,
         rationale: reason
       });
     }

     // Output as markdown table format
     console.log('| Pattern | Model | Priority | Evidence |');
     console.log('|---------|-------|----------|----------|');
     for (const s of suggestions) {
       console.log(`| ${s.pattern} | ${s.model} | ${s.priority} | ${s.evidence} |`);
     }
   }
   ```

This output can be reviewed and merged into routing-rules.md.
  </action>
  <verify>
Run suggest-rules on scan output and see markdown table of suggested rules
  </verify>
  <done>
Rule suggestion from patterns:
- Analyzes keyword frequency
- Maps to model tiers based on complexity
- Outputs markdown table format
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 4: Review generated routing rules (human checkpoint)</name>
  <what-built>
Session scanning and rule generation for igaming-platform project:
1. Scanned last 5-7 days of sessions
2. Extracted task patterns
3. Generated suggested routing rules
  </what-built>
  <how-to-verify>
1. Review the generated routing rules table
2. Check if model assignments make sense for the patterns
3. Correct any misassigned models
4. Approve or modify the rules

Expected output format:
```
| Pattern | Model | Priority | Evidence |
|---------|-------|----------|----------|
| supabase | sonnet | 2 | Found 15 times in sessions |
| rls | sonnet | 2 | Found 12 times in sessions |
| button | haiku | 1 | Found 8 times in sessions |
```
  </how-to-verify>
  <resume-signal>
Type "approved" to merge rules into routing-rules.md, or provide corrections in format:
`pattern:model` (e.g., "supabase:opus" to change supabase to opus)
  </resume-signal>
</task>

<task type="auto">
  <name>Task 5: Merge approved rules into routing files</name>
  <files>~/.claude/routing-rules.md, .planning/routing/project-rules.md</files>
  <action>
After user approval, merge the suggested rules:

1. Read approved rules (from checkpoint feedback or default suggestions)

2. For global rules (general patterns like "test", "refactor"):
   - Append to `~/.claude/routing-rules.md` table
   - Preserve existing rules, add new ones at end
   - Add comment: `# Rules generated from igaming-platform session scan (YYYY-MM-DD)`

3. For project-specific rules (domain terms like "supabase", "rls", project names):
   - Add to `.planning/routing/project-rules.md`
   - These are project-specific patterns

4. Verify no duplicate patterns (same pattern in both files)

5. Output summary of rules added:
   ```
   Added to global rules: N patterns
   Added to project rules: M patterns
   Total new rules: N+M
   ```
  </action>
  <verify>
1. `cat ~/.claude/routing-rules.md` shows new rules added
2. `cat .planning/routing/project-rules.md` shows project-specific rules
3. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing match "create supabase function"` uses new rules
  </verify>
  <done>
Rules merged:
- Global rules updated with common patterns
- Project rules updated with domain patterns
- Ready for auto mode routing
  </done>
</task>

</tasks>

<verification>
1. Session scanning works on igaming-platform project
2. Generated rules reviewed and approved by user
3. Rules merged into appropriate files (global vs project)
4. Routing commands use new rules for matching
</verification>

<success_criteria>
- Real usage patterns extracted from sessions
- Rules generated with evidence-based model assignments
- User reviewed and approved rules before merge
- Both global and project-specific rules populated
</success_criteria>

<output>
After completion, create `.planning/phases/01-auto-mode-foundation/01-05-SUMMARY.md`
</output>
