---
phase: 01-auto-mode-foundation
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - ~/.claude/get-shit-done/bin/gsd-tools.js
  - ~/.claude/get-shit-done/agents/gsd-task-router.md
autonomous: true

must_haves:
  truths:
    - "Task context skill returns model recommendation for any task description"
    - "Skill injects top 3 relevant docs/guides based on keyword matching"
    - "CLAUDE.md instructions are extracted and matched via keywords"
  artifacts:
    - path: "~/.claude/get-shit-done/agents/gsd-task-router.md"
      provides: "Task routing skill definition"
      contains: "model recommendation"
    - path: "~/.claude/get-shit-done/bin/gsd-tools.js"
      provides: "Context indexing and matching functions"
      exports: ["buildContextIndex", "matchContextDocs"]
  key_links:
    - from: "gsd-task-router.md"
      to: "gsd-tools.js"
      via: "routing and context commands"
      pattern: "routing context|context match"
---

<objective>
Create the Task Context Skill that returns model recommendation plus relevant context injection (top 3 guides/docs) for each task.

Purpose: Enable intelligent model selection AND active context injection to solve Claude ignoring CLAUDE.md instructions.
Output: gsd-task-router agent/skill that coordinators call before spawning tasks.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auto-mode-foundation/01-CONTEXT.md
@.planning/phases/01-auto-mode-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add context indexing to gsd-tools.js</name>
  <files>~/.claude/get-shit-done/bin/gsd-tools.js</files>
  <action>
Add functions for building and querying a context index of docs/guides:

1. `extractKeywords(text)` — Simple keyword extraction:
   ```javascript
   function extractKeywords(text) {
     const stopWords = new Set([
       'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
       'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had',
       'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might',
       'must', 'can', 'this', 'that', 'these', 'those', 'it', 'its', 'with',
       'from', 'by', 'as', 'of', 'if', 'then', 'else', 'when', 'where', 'how',
       'what', 'which', 'who', 'why', 'not', 'no', 'yes', 'all', 'any', 'each'
     ]);
     return text
       .toLowerCase()
       .split(/\W+/)
       .filter(word => word.length > 2 && !stopWords.has(word));
   }
   ```

2. `buildContextIndex(basePaths)` — Build searchable index from docs:
   ```javascript
   function buildContextIndex(basePaths) {
     const index = { entries: [], created_at: new Date().toISOString() };

     for (const basePath of basePaths) {
       if (!fs.existsSync(basePath)) continue;

       const findMd = (dir) => {
         const files = [];
         for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
           const fullPath = path.join(dir, entry.name);
           if (entry.isDirectory()) {
             files.push(...findMd(fullPath));
           } else if (entry.name.endsWith('.md')) {
             files.push(fullPath);
           }
         }
         return files;
       };

       for (const file of findMd(basePath)) {
         try {
           const content = fs.readFileSync(file, 'utf-8');
           const frontmatter = extractFrontmatter(content);
           const tags = frontmatter.tags || [];
           const keywords = extractKeywords(content);
           const mtime = fs.statSync(file).mtime;

           index.entries.push({
             path: file,
             tags: Array.isArray(tags) ? tags : [tags],
             keywords: [...new Set(keywords)].slice(0, 100), // Limit to top 100 unique
             mtime: mtime.toISOString(),
             title: frontmatter.title || path.basename(file, '.md')
           });
         } catch (err) {
           // Skip unreadable files
         }
       }
     }

     return index;
   }
   ```

3. `matchContextDocs(taskDescription, index, limit = 3)` — Find top N matching docs:
   ```javascript
   function matchContextDocs(taskDescription, index, limit = 3) {
     const taskKeywords = extractKeywords(taskDescription);

     const scored = index.entries.map(entry => {
       // Score = tags matches (weighted 2x) + keyword matches
       const tagMatches = entry.tags.filter(t =>
         taskKeywords.some(k => t.toLowerCase().includes(k) || k.includes(t.toLowerCase()))
       ).length * 2;

       const keywordMatches = entry.keywords.filter(k =>
         taskKeywords.includes(k)
       ).length;

       return {
         ...entry,
         score: tagMatches + keywordMatches
       };
     });

     return scored
       .filter(e => e.score > 0)
       .sort((a, b) => b.score - a.score)
       .slice(0, limit)
       .map(e => ({ path: e.path, title: e.title, score: e.score }));
   }
   ```

4. `extractClaudeInstructions(claudeMdPath)` — Parse CLAUDE.md for instruction blocks:
   ```javascript
   function extractClaudeInstructions(claudeMdPath) {
     const content = safeReadFile(claudeMdPath);
     if (!content) return { keywords: [], instructions: [] };

     // Extract keywords from the entire file
     const keywords = extractKeywords(content);

     // Extract instruction blocks (lines starting with - or numbered lists)
     const instructions = content
       .split('\n')
       .filter(l => l.match(/^[-*]\s+/) || l.match(/^\d+\.\s+/))
       .map(l => l.replace(/^[-*\d.]+\s+/, '').trim())
       .filter(l => l.length > 10);

     return { keywords: [...new Set(keywords)], instructions };
   }
   ```

5. Add CLI command `routing context <task-description>`:
   ```javascript
   if (command === 'routing' && subCommand === 'context') {
     const taskDesc = args.slice(2).join(' ');
     const basePaths = [
       path.join(HOME, '.claude', 'guides'),
       path.join(HOME, '.claude', 'get-shit-done', 'references'),
       path.join(cwd, '.planning', 'codebase')
     ];
     const index = buildContextIndex(basePaths);
     const matches = matchContextDocs(taskDesc, index, 3);
     console.log(JSON.stringify({ task: taskDesc, matches, index_size: index.entries.length }, null, 2));
   }
   ```

6. Add CLI command `routing full <task-description>` — Combined model + context:
   ```javascript
   if (command === 'routing' && subCommand === 'full') {
     const taskDesc = args.slice(2).join(' ');

     // Load routing rules
     const globalRules = loadRoutingRules(path.join(HOME, '.claude', 'routing-rules.md'));
     const projectRules = loadRoutingRules(path.join(cwd, '.planning', 'routing', 'project-rules.md'));
     const merged = mergeRoutingRules(globalRules, projectRules);
     const modelResult = selectModelFromRules(taskDesc, merged);

     // Load context index
     const basePaths = [
       path.join(HOME, '.claude', 'guides'),
       path.join(HOME, '.claude', 'get-shit-done', 'references'),
       path.join(cwd, '.planning', 'codebase')
     ];
     const index = buildContextIndex(basePaths);
     const contextMatches = matchContextDocs(taskDesc, index, 3);

     // Extract CLAUDE.md instructions
     const claudeInstructions = extractClaudeInstructions(path.join(cwd, 'CLAUDE.md'));

     console.log(JSON.stringify({
       task: taskDesc,
       model: modelResult,
       context: contextMatches,
       claude_md: {
         has_instructions: claudeInstructions.instructions.length > 0,
         relevant_keywords: claudeInstructions.keywords.filter(k =>
           extractKeywords(taskDesc).includes(k)
         ).slice(0, 10)
       }
     }, null, 2));
   }
   ```
  </action>
  <verify>
Run: `node ~/.claude/get-shit-done/bin/gsd-tools.js routing full "Add supabase authentication middleware"`
Should return JSON with:
- model recommendation
- top 3 matching context docs
- relevant CLAUDE.md keywords
  </verify>
  <done>
Context indexing and matching works:
- Extracts keywords from docs and CLAUDE.md
- Matches task descriptions against doc tags and content
- Returns top 3 relevant docs for injection
  </done>
</task>

<task type="auto">
  <name>Task 2: Create gsd-task-router agent</name>
  <files>~/.claude/get-shit-done/agents/gsd-task-router.md</files>
  <action>
Create `~/.claude/get-shit-done/agents/gsd-task-router.md`:

```markdown
---
name: gsd-task-router
description: Routes tasks to appropriate model tiers and injects relevant context. Called by coordinators before spawning task agents.
tools: Bash
color: cyan
---

<role>
You are the GSD Task Router. Given a task description, you determine:
1. Which model tier should execute it (haiku/sonnet/opus)
2. Which docs/guides/skills should be injected as context
3. Any relevant project-specific instructions from CLAUDE.md

You do NOT execute tasks. You provide routing decisions that coordinators use when spawning task agents.
</role>

<input>
You receive a task description as your prompt. Extract the key intent and match against routing rules.
</input>

<process>
1. **Get routing decision:**
   ```bash
   node ~/.claude/get-shit-done/bin/gsd-tools.js routing full "<task description>"
   ```

2. **Parse the JSON result** containing:
   - `model`: Recommended model tier
   - `context`: Top 3 matching docs
   - `claude_md`: Relevant CLAUDE.md keywords

3. **Return structured decision** in this exact format:
   ```
   ## ROUTING DECISION

   **Model:** <haiku|sonnet|opus>
   **Reason:** <rationale from pattern match or "default">

   **Context Injection:**
   - @<path/to/doc1.md>
   - @<path/to/doc2.md>
   - @<path/to/doc3.md>

   **CLAUDE.md Keywords:** <comma-separated list or "none">

   ---
   <raw JSON for debugging>
   ```
</process>

<output>
Return the routing decision in the format above. The coordinator will:
1. Use the model tier for Task spawn
2. Include the @context references in the task prompt
3. Inject CLAUDE.md keywords as reminders
</output>

<important>
- Always return a decision, even if no patterns match (default to sonnet)
- If no context docs match, return empty list
- Do not add commentary or suggestions — just return the decision
- This is a fast, low-context operation — complete quickly
</important>
```
  </action>
  <verify>File exists at ~/.claude/get-shit-done/agents/gsd-task-router.md with proper structure</verify>
  <done>gsd-task-router agent created with routing decision format</done>
</task>

<task type="auto">
  <name>Task 3: Add context index caching</name>
  <files>~/.claude/get-shit-done/bin/gsd-tools.js</files>
  <action>
Add caching for the context index to avoid rebuilding on every call:

1. Add cache location: `~/.claude/cache/context-index.json`

2. Add `routing index-build [--force]` command:
   ```javascript
   if (command === 'routing' && subCommand === 'index-build') {
     const force = args.includes('--force');
     const cachePath = path.join(HOME, '.claude', 'cache', 'context-index.json');

     // Check if cache exists and is fresh (< 1 hour old)
     if (!force && fs.existsSync(cachePath)) {
       const stat = fs.statSync(cachePath);
       const ageMs = Date.now() - stat.mtime.getTime();
       if (ageMs < 3600000) { // 1 hour
         console.log(JSON.stringify({ cached: true, age_minutes: Math.floor(ageMs / 60000) }));
         return;
       }
     }

     const basePaths = [
       path.join(HOME, '.claude', 'guides'),
       path.join(HOME, '.claude', 'get-shit-done', 'references'),
       path.join(cwd, '.planning', 'codebase')
     ];
     const index = buildContextIndex(basePaths);

     fs.mkdirSync(path.dirname(cachePath), { recursive: true });
     fs.writeFileSync(cachePath, JSON.stringify(index, null, 2));

     console.log(JSON.stringify({ cached: false, entries: index.entries.length }));
   }
   ```

3. Update `routing context` and `routing full` to use cache:
   ```javascript
   function loadContextIndex(cwd) {
     const cachePath = path.join(HOME, '.claude', 'cache', 'context-index.json');

     // Try cache first
     if (fs.existsSync(cachePath)) {
       try {
         return JSON.parse(fs.readFileSync(cachePath, 'utf-8'));
       } catch {
         // Fall through to rebuild
       }
     }

     // Rebuild and cache
     const basePaths = [
       path.join(HOME, '.claude', 'guides'),
       path.join(HOME, '.claude', 'get-shit-done', 'references'),
       path.join(cwd, '.planning', 'codebase')
     ];
     const index = buildContextIndex(basePaths);

     fs.mkdirSync(path.dirname(cachePath), { recursive: true });
     fs.writeFileSync(cachePath, JSON.stringify(index, null, 2));

     return index;
   }
   ```

4. Add `routing index-refresh` command to check file mtimes and refresh if needed:
   ```javascript
   if (command === 'routing' && subCommand === 'index-refresh') {
     const cachePath = path.join(HOME, '.claude', 'cache', 'context-index.json');
     if (!fs.existsSync(cachePath)) {
       // Trigger full build
       // ... (call index-build logic)
       return;
     }

     const cached = JSON.parse(fs.readFileSync(cachePath, 'utf-8'));
     const cacheTime = new Date(cached.created_at);

     // Check if any indexed file has been modified since cache
     const stale = cached.entries.some(entry => {
       if (!fs.existsSync(entry.path)) return true; // File deleted
       const mtime = fs.statSync(entry.path).mtime;
       return mtime > cacheTime;
     });

     console.log(JSON.stringify({ stale, entries: cached.entries.length }));
   }
   ```

This implements user decision: "Hybrid: index once per session, refresh on file changes"
  </action>
  <verify>
Run:
1. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing index-build --force`
2. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing index-build` (should return cached: true)
3. `cat ~/.claude/cache/context-index.json | head -50`
  </verify>
  <done>
Context index caching works:
- Builds index from docs/guides/references
- Caches to ~/.claude/cache/context-index.json
- Refreshes when files change
- Force rebuild available
  </done>
</task>

</tasks>

<verification>
1. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing full "create supabase RLS policy"` returns model + context
2. `cat ~/.claude/get-shit-done/agents/gsd-task-router.md` shows valid agent definition
3. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing index-build --force` rebuilds index
4. `ls ~/.claude/cache/context-index.json` shows cached index
5. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing index-refresh` shows stale status
</verification>

<success_criteria>
- gsd-task-router agent provides model + context decisions
- Context index built from ~/.claude/guides, references, and .planning/codebase
- Top 3 matching docs returned based on tag + keyword matching
- CLAUDE.md keywords extracted for relevance checking
- Index caching with mtime-based refresh
</success_criteria>

<output>
After completion, create `.planning/phases/01-auto-mode-foundation/01-02-SUMMARY.md`
</output>
