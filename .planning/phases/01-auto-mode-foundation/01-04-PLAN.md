---
phase: 01-auto-mode-foundation
plan: 04
type: execute
wave: 3
depends_on: [01-02, 01-03]
files_modified:
  - ~/.claude/get-shit-done/workflows/set-profile.md
  - ~/.claude/get-shit-done/bin/gsd-tools.js
  - .planning/config.json
autonomous: true

must_haves:
  truths:
    - "User can set profile to 'auto' via /gsd:set-profile"
    - "Auto profile routes tasks through gsd-task-router"
    - "Status bar shows real-time token tracking"
    - "On-request command shows detailed usage breakdown"
  artifacts:
    - path: "~/.claude/get-shit-done/workflows/set-profile.md"
      provides: "Auto profile option"
      contains: "auto"
    - path: "~/.claude/get-shit-done/bin/gsd-tools.js"
      provides: "Status formatting and stats commands"
      exports: ["formatStatusBar", "getUsageStats"]
  key_links:
    - from: "set-profile.md"
      to: "config.json"
      via: "profile setting"
      pattern: "model_profile.*auto"
---

<objective>
Add auto profile to `/gsd:set-profile`, implement status bar format, and create on-request stats command.

Purpose: Enable users to activate auto mode and monitor token savings in real-time.
Output: Auto profile option and usage display working.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auto-mode-foundation/01-CONTEXT.md
@.planning/phases/01-auto-mode-foundation/01-02-SUMMARY.md
@.planning/phases/01-auto-mode-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auto profile to set-profile workflow</name>
  <files>~/.claude/get-shit-done/workflows/set-profile.md</files>
  <action>
Update `~/.claude/get-shit-done/workflows/set-profile.md` to include auto profile:

1. Add auto to valid profiles list:
   ```markdown
   ## Valid Profiles

   - **quality** — Maximum reasoning power (Opus for decisions, Sonnet for verification)
   - **balanced** — Smart allocation (default, good balance of quality and cost)
   - **budget** — Minimal Opus usage (Sonnet for code, Haiku for research/verification)
   - **auto** — Intelligent routing per task based on complexity patterns
   ```

2. Add auto profile description:
   ```markdown
   ### Auto Profile

   Auto mode routes each task to the most appropriate model based on:
   - Task description keyword matching against routing rules
   - Project-specific overrides in `.planning/routing/project-rules.md`
   - Global rules in `~/.claude/routing-rules.md`

   When auto is active:
   - Tasks are analyzed before spawning via gsd-task-router
   - Model selection happens per-task, not per-workflow
   - Token savings tracked in `.planning/quota/session-usage.json`
   - Status bar shows: `Tokens: 32K → Haiku | +15 min | H:60% S:35% O:5%`

   **Fallback behavior:** Sonnet when no patterns match (safety over savings)
   ```

3. Add validation in the workflow to accept 'auto':
   ```markdown
   ## Validation

   Profile must be one of: `quality`, `balanced`, `budget`, `auto`

   If invalid, show error and list valid options.
   ```

4. Update the config update logic to handle auto:
   ```bash
   node ~/.claude/get-shit-done/bin/gsd-tools.js config set model_profile "$PROFILE"
   ```
  </action>
  <verify>Read ~/.claude/get-shit-done/workflows/set-profile.md and confirm auto profile documented</verify>
  <done>set-profile workflow accepts 'auto' as valid profile</done>
</task>

<task type="auto">
  <name>Task 2: Implement status bar format function</name>
  <files>~/.claude/get-shit-done/bin/gsd-tools.js</files>
  <action>
Add function to format status bar per user decision: `Tokens: 32K → Haiku | +15 min | H:60% S:35% O:5%`

1. `formatStatusBar(quotaState)` — Generate status bar string:
   ```javascript
   function formatStatusBar(quotaState) {
     // Calculate tokens delegated to smaller models
     const tasks = quotaState.tasks || [];
     const totalTokens = tasks.reduce((sum, t) => sum + t.tokens_in + t.tokens_out, 0);

     // Calculate model distribution
     const modelCounts = { haiku: 0, sonnet: 0, opus: 0 };
     for (const task of tasks) {
       const model = task.model.toLowerCase();
       if (modelCounts[model] !== undefined) {
         modelCounts[model] += task.tokens_in + task.tokens_out;
       }
     }

     const total = modelCounts.haiku + modelCounts.sonnet + modelCounts.opus || 1;
     const hPercent = Math.round((modelCounts.haiku / total) * 100);
     const sPercent = Math.round((modelCounts.sonnet / total) * 100);
     const oPercent = Math.round((modelCounts.opus / total) * 100);

     // Format token count (K for thousands)
     const tokensK = totalTokens >= 1000 ? `${Math.round(totalTokens / 1000)}K` : totalTokens;

     // Determine most recent model (for "→ Haiku" part)
     const lastTask = tasks[tasks.length - 1];
     const lastModel = lastTask ? lastTask.model : 'none';

     // Estimate time extension (rough: 1K tokens = ~30 seconds saved vs Opus)
     // Using haiku is ~10x cheaper than Opus, sonnet ~5x cheaper
     const haikuSavings = modelCounts.haiku * 0.9; // 90% savings vs opus
     const sonnetSavings = modelCounts.sonnet * 0.5; // 50% savings vs opus
     const savedTokenValue = haikuSavings + sonnetSavings;
     const savedMinutes = Math.round(savedTokenValue / 2000); // Rough estimate

     return `Tokens: ${tokensK} → ${lastModel} | +${savedMinutes} min | H:${hPercent}% S:${sPercent}% O:${oPercent}%`;
   }
   ```

2. CLI command `quota status-bar`:
   ```javascript
   if (command === 'quota' && subCommand === 'status-bar') {
     const state = loadQuotaState(cwd);
     const statusBar = formatStatusBar(state);
     console.log(statusBar);
   }
   ```

3. CLI command `quota status-bar --json` for programmatic use:
   ```javascript
   if (command === 'quota' && subCommand === 'status-bar') {
     const state = loadQuotaState(cwd);

     if (args.includes('--json')) {
       const tasks = state.tasks || [];
       const modelCounts = { haiku: 0, sonnet: 0, opus: 0 };
       for (const task of tasks) {
         const model = task.model.toLowerCase();
         if (modelCounts[model] !== undefined) {
           modelCounts[model] += task.tokens_in + task.tokens_out;
         }
       }
       console.log(JSON.stringify({
         total_tokens: tasks.reduce((sum, t) => sum + t.tokens_in + t.tokens_out, 0),
         model_distribution: modelCounts,
         task_count: tasks.length,
         last_model: tasks[tasks.length - 1]?.model || null
       }, null, 2));
     } else {
       const statusBar = formatStatusBar(state);
       console.log(statusBar);
     }
   }
   ```
  </action>
  <verify>
Run:
1. Record some test tasks: `node ~/.claude/get-shit-done/bin/gsd-tools.js quota record t1 haiku 1000 500`
2. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota status-bar` shows formatted bar
3. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota status-bar --json` shows JSON
  </verify>
  <done>
Status bar formatting:
- Shows total tokens delegated
- Shows last model used
- Shows time extension estimate
- Shows model distribution percentages
  </done>
</task>

<task type="auto">
  <name>Task 3: Create detailed usage stats command</name>
  <files>~/.claude/get-shit-done/bin/gsd-tools.js</files>
  <action>
Add on-request command for detailed session stats per user decision:

1. CLI command `quota stats`:
   ```javascript
   if (command === 'quota' && subCommand === 'stats') {
     const state = loadQuotaState(cwd);
     const tasks = state.tasks || [];

     // Calculate per-model breakdown
     const models = { haiku: { tokens: 0, tasks: 0 }, sonnet: { tokens: 0, tasks: 0 }, opus: { tokens: 0, tasks: 0 } };
     for (const task of tasks) {
       const model = task.model.toLowerCase();
       if (models[model]) {
         models[model].tokens += task.tokens_in + task.tokens_out;
         models[model].tasks += 1;
       }
     }

     // Calculate estimated cost savings (rough estimates)
     // Opus: $15/M input, $75/M output
     // Sonnet: $3/M input, $15/M output
     // Haiku: $0.25/M input, $1.25/M output
     const opusCost = (models.opus.tokens / 1000000) * 45; // Avg of input/output
     const sonnetCost = (models.sonnet.tokens / 1000000) * 9;
     const haikuCost = (models.haiku.tokens / 1000000) * 0.75;

     // If all tasks were Opus
     const totalTokens = models.haiku.tokens + models.sonnet.tokens + models.opus.tokens;
     const allOpusCost = (totalTokens / 1000000) * 45;
     const actualCost = opusCost + sonnetCost + haikuCost;
     const savings = allOpusCost - actualCost;
     const savingsPercent = allOpusCost > 0 ? (savings / allOpusCost) * 100 : 0;

     // Format table output
     const output = {
       session_total: {
         tokens: totalTokens,
         tasks: tasks.length,
         duration_minutes: tasks.length > 0
           ? Math.round((new Date() - new Date(tasks[0].timestamp)) / 60000)
           : 0
       },
       per_model: {
         haiku: models.haiku,
         sonnet: models.sonnet,
         opus: models.opus
       },
       cost_estimate: {
         actual_cost: `$${actualCost.toFixed(4)}`,
         if_all_opus: `$${allOpusCost.toFixed(4)}`,
         savings: `$${savings.toFixed(4)}`,
         savings_percent: `${savingsPercent.toFixed(1)}%`
       },
       quota: {
         session_used: state.session.tokens_used,
         session_limit: state.session.tokens_limit,
         session_percent: ((state.session.tokens_used / state.session.tokens_limit) * 100).toFixed(1) + '%',
         weekly_used: state.weekly.tokens_used,
         weekly_limit: state.weekly.tokens_limit,
         weekly_percent: ((state.weekly.tokens_used / state.weekly.tokens_limit) * 100).toFixed(1) + '%'
       }
     };

     if (args.includes('--table')) {
       // Print as formatted table
       console.log('\n=== GSD Auto Mode Session Stats ===\n');
       console.log(`Total: ${totalTokens.toLocaleString()} tokens across ${tasks.length} tasks\n`);
       console.log('Model Distribution:');
       console.log(`  Haiku:  ${models.haiku.tokens.toLocaleString()} tokens (${models.haiku.tasks} tasks)`);
       console.log(`  Sonnet: ${models.sonnet.tokens.toLocaleString()} tokens (${models.sonnet.tasks} tasks)`);
       console.log(`  Opus:   ${models.opus.tokens.toLocaleString()} tokens (${models.opus.tasks} tasks)`);
       console.log('\nCost Savings:');
       console.log(`  Actual:    ${output.cost_estimate.actual_cost}`);
       console.log(`  If Opus:   ${output.cost_estimate.if_all_opus}`);
       console.log(`  Saved:     ${output.cost_estimate.savings} (${output.cost_estimate.savings_percent})`);
       console.log('\nQuota:');
       console.log(`  Session:   ${output.quota.session_percent} used`);
       console.log(`  Weekly:    ${output.quota.weekly_percent} used`);
     } else {
       console.log(JSON.stringify(output, null, 2));
     }
   }
   ```
  </action>
  <verify>
Run:
1. Record multiple test tasks with different models
2. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota stats` shows JSON
3. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota stats --table` shows formatted table
  </verify>
  <done>
Detailed stats command:
- Per-model token and task breakdown
- Cost savings estimate vs all-Opus
- Session and weekly quota percentages
- Table and JSON output formats
  </done>
</task>

</tasks>

<verification>
1. `/gsd:set-profile auto` accepted and saved to config
2. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota status-bar` shows formatted status
3. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota stats --table` shows detailed breakdown
4. Cost savings calculation produces reasonable percentages
</verification>

<success_criteria>
- Auto profile documented and accepted by set-profile
- Status bar format matches user spec: `Tokens: XXK → Model | +N min | H:X% S:X% O:X%`
- Stats command shows per-model breakdown and savings estimate
- Both JSON and table output formats available
</success_criteria>

<output>
After completion, create `.planning/phases/01-auto-mode-foundation/01-04-SUMMARY.md`
</output>
