---
phase: 01-auto-mode-foundation
plan: 06
type: execute
wave: 4
depends_on: [01-02, 01-03, 01-04]
files_modified:
  - ~/.claude/get-shit-done/workflows/execute-plan.md
  - ~/.claude/get-shit-done/bin/gsd-tools.js
  - .planning/routing/routing-stats.jsonl
autonomous: true

must_haves:
  truths:
    - "Execute-plan workflow uses gsd-task-router when auto profile active"
    - "Task spawns include model parameter from routing decision"
    - "Unmatched tasks logged for future rule improvement"
    - "Fallback to Sonnet works when routing fails"
  artifacts:
    - path: "~/.claude/get-shit-done/workflows/execute-plan.md"
      provides: "Auto mode integration in execution"
      contains: "gsd-task-router"
    - path: ".planning/routing/routing-stats.jsonl"
      provides: "Unmatched task log"
      contains: "fallback"
  key_links:
    - from: "execute-plan.md"
      to: "gsd-task-router"
      via: "routing decision call"
      pattern: "routing full|model parameter"
---

<objective>
Integrate auto mode routing into execute-plan workflow with fallback behavior and unmatched task logging.

Purpose: Complete the auto mode integration so tasks are routed through the system.
Output: Execute-plan uses routing when auto profile active, logs unmatched tasks.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auto-mode-foundation/01-CONTEXT.md
@.planning/phases/01-auto-mode-foundation/01-02-SUMMARY.md
@.planning/phases/01-auto-mode-foundation/01-03-SUMMARY.md
@.planning/phases/01-auto-mode-foundation/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unmatched task logging</name>
  <files>~/.claude/get-shit-done/bin/gsd-tools.js, .planning/routing/routing-stats.jsonl</files>
  <action>
Add logging for tasks that fall back to default model:

1. Add `routing log-fallback <task-description> <reason>` command:
   ```javascript
   if (command === 'routing' && subCommand === 'log-fallback') {
     const taskDesc = args[2];
     const reason = args[3] || 'no pattern match';

     const logPath = path.join(cwd, '.planning', 'routing', 'routing-stats.jsonl');
     fs.mkdirSync(path.dirname(logPath), { recursive: true });

     const entry = {
       timestamp: new Date().toISOString(),
       task: taskDesc,
       model: 'sonnet',
       reason: 'fallback',
       details: reason
     };

     fs.appendFileSync(logPath, JSON.stringify(entry) + '\n');
     console.log(JSON.stringify({ logged: true }));
   }
   ```

2. Add `routing analyze-fallbacks` command to review unmatched patterns:
   ```javascript
   if (command === 'routing' && subCommand === 'analyze-fallbacks') {
     const logPath = path.join(cwd, '.planning', 'routing', 'routing-stats.jsonl');

     if (!fs.existsSync(logPath)) {
       console.log(JSON.stringify({ fallbacks: 0, patterns: [] }));
       return;
     }

     const lines = fs.readFileSync(logPath, 'utf-8').split('\n').filter(Boolean);
     const entries = lines.map(l => {
       try { return JSON.parse(l); } catch { return null; }
     }).filter(Boolean);

     // Only fallback entries
     const fallbacks = entries.filter(e => e.reason === 'fallback');

     // Extract common keywords from fallback tasks
     const keywordCounts = {};
     for (const f of fallbacks) {
       const keywords = extractKeywords(f.task);
       for (const k of keywords) {
         keywordCounts[k] = (keywordCounts[k] || 0) + 1;
       }
     }

     // Top patterns that need rules
     const topPatterns = Object.entries(keywordCounts)
       .sort((a, b) => b[1] - a[1])
       .slice(0, 20)
       .map(([pattern, count]) => ({ pattern, count }));

     console.log(JSON.stringify({
       total_fallbacks: fallbacks.length,
       unique_keywords: Object.keys(keywordCounts).length,
       suggested_patterns: topPatterns
     }, null, 2));
   }
   ```

3. Also log successful matches for stats:
   ```javascript
   if (command === 'routing' && subCommand === 'log-match') {
     const taskDesc = args[2];
     const model = args[3];
     const pattern = args[4] || 'unknown';

     const logPath = path.join(cwd, '.planning', 'routing', 'routing-stats.jsonl');
     fs.mkdirSync(path.dirname(logPath), { recursive: true });

     const entry = {
       timestamp: new Date().toISOString(),
       task: taskDesc,
       model: model,
       reason: 'matched',
       pattern: pattern
     };

     fs.appendFileSync(logPath, JSON.stringify(entry) + '\n');
     console.log(JSON.stringify({ logged: true }));
   }
   ```
  </action>
  <verify>
Run:
1. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing log-fallback "some task" "no pattern"`
2. `cat .planning/routing/routing-stats.jsonl` shows entry
3. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing analyze-fallbacks` shows analysis
  </verify>
  <done>
Fallback logging implemented:
- Logs unmatched tasks to routing-stats.jsonl
- Logs matched tasks for stats
- Analyze command finds patterns for new rules
  </done>
</task>

<task type="auto">
  <name>Task 2: Add escalation ladder logic</name>
  <files>~/.claude/get-shit-done/bin/gsd-tools.js</files>
  <action>
Implement escalation ladder per user decision: Haiku → Sonnet → Opus before failing.

1. Add timeout tracking per task:
   ```javascript
   const TIMEOUTS = {
     haiku: 20 * 60 * 1000,   // 20 minutes
     sonnet: 40 * 60 * 1000,  // 40 minutes
     opus: 60 * 60 * 1000     // 1 hour
   };

   function getTaskTimeout(model) {
     return TIMEOUTS[model.toLowerCase()] || TIMEOUTS.sonnet;
   }
   ```

2. Add `routing escalate <current-model>` command:
   ```javascript
   if (command === 'routing' && subCommand === 'escalate') {
     const currentModel = (args[2] || 'haiku').toLowerCase();
     const ladder = ['haiku', 'sonnet', 'opus'];
     const currentIdx = ladder.indexOf(currentModel);

     if (currentIdx === -1 || currentIdx >= ladder.length - 1) {
       console.log(JSON.stringify({
         can_escalate: false,
         current: currentModel,
         next: null,
         reason: currentIdx === -1 ? 'unknown model' : 'already at opus'
       }));
       return;
     }

     const nextModel = ladder[currentIdx + 1];
     console.log(JSON.stringify({
       can_escalate: true,
       current: currentModel,
       next: nextModel,
       timeout_ms: getTaskTimeout(nextModel)
     }));
   }
   ```

3. Add `routing timeout-info <model>` command:
   ```javascript
   if (command === 'routing' && subCommand === 'timeout-info') {
     const model = (args[2] || 'sonnet').toLowerCase();
     console.log(JSON.stringify({
       model: model,
       timeout_ms: getTaskTimeout(model),
       timeout_minutes: Math.round(getTaskTimeout(model) / 60000)
     }));
   }
   ```
  </action>
  <verify>
Run:
1. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing escalate haiku` returns sonnet
2. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing escalate sonnet` returns opus
3. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing escalate opus` returns can_escalate: false
4. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing timeout-info haiku` returns 20 minutes
  </verify>
  <done>
Escalation ladder:
- Haiku → Sonnet → Opus progression
- Configurable timeouts per model
- Escalate command for coordinator use
  </done>
</task>

<task type="auto">
  <name>Task 3: Update execute-plan workflow for auto mode</name>
  <files>~/.claude/get-shit-done/workflows/execute-plan.md</files>
  <action>
Update execute-plan.md to use routing when auto profile is active:

1. Add auto mode detection section:
   ```markdown
   ## Auto Mode Detection

   Before spawning task agents, check if auto mode is active:

   ```bash
   PROFILE=$(node ~/.claude/get-shit-done/bin/gsd-tools.js state get model_profile)
   ```

   If `model_profile` is "auto", use the routing system for each task.
   ```

2. Add routing integration section:
   ```markdown
   ## Task Routing (Auto Mode)

   When auto mode is active, for each task:

   1. **Get routing decision:**
      ```bash
      ROUTING=$(node ~/.claude/get-shit-done/bin/gsd-tools.js routing full "<task description>")
      MODEL=$(echo $ROUTING | jq -r '.model.model')
      CONTEXT=$(echo $ROUTING | jq -r '.context[].path' | head -3)
      ```

   2. **Check quota before spawning:**
      ```bash
      QUOTA_CHECK=$(node ~/.claude/get-shit-done/bin/gsd-tools.js quota check)
      SHOULD_WAIT=$(echo $QUOTA_CHECK | jq -r '.wait.should_wait')

      if [ "$SHOULD_WAIT" = "true" ]; then
        WAIT_SEC=$(echo $QUOTA_CHECK | jq -r '.wait.wait_seconds')
        echo "Quota limit reached. Waiting ${WAIT_SEC}s for reset..."
        sleep $WAIT_SEC
      fi
      ```

   3. **Spawn task with model parameter:**
      Include `model: $MODEL` in Task spawn and inject context docs.

   4. **Record usage after task completes:**
      ```bash
      node ~/.claude/get-shit-done/bin/gsd-tools.js quota record <task-id> <model> <tokens-in> <tokens-out>
      ```

   5. **Log routing decision:**
      ```bash
      if [ "$MODEL" = "sonnet" ] && [ "$(echo $ROUTING | jq -r '.model.matched')" = "false" ]; then
        node ~/.claude/get-shit-done/bin/gsd-tools.js routing log-fallback "<task desc>" "no pattern"
      else
        node ~/.claude/get-shit-done/bin/gsd-tools.js routing log-match "<task desc>" "$MODEL" "<pattern>"
      fi
      ```
   ```

3. Add fallback behavior section:
   ```markdown
   ## Fallback Behavior

   - If routing fails (error parsing, missing rules): use Sonnet
   - If task times out: escalate via `routing escalate <model>`
   - If task fails: log and attempt escalation
   - After full ladder (Opus fails): report failure to user

   ### Escalation Flow

   ```
   Task assigned to Haiku → timeout/fail
   ↓
   Escalate to Sonnet → timeout/fail
   ↓
   Escalate to Opus → timeout/fail
   ↓
   Report failure, pause for user
   ```
   ```

4. Add status display section:
   ```markdown
   ## Status Display

   After each task completes, update status bar:

   ```bash
   STATUS=$(node ~/.claude/get-shit-done/bin/gsd-tools.js quota status-bar)
   echo "$STATUS"
   ```

   Shows: `Tokens: 32K → Haiku | +15 min | H:60% S:35% O:5%`
   ```
  </action>
  <verify>Read execute-plan.md and confirm auto mode sections added</verify>
  <done>
Execute-plan updated:
- Auto mode detection
- Routing integration for task spawning
- Quota check and auto-wait
- Fallback and escalation logic
- Status bar display
  </done>
</task>

</tasks>

<verification>
1. Execute-plan.md documents auto mode routing flow
2. `routing log-fallback` and `routing log-match` commands work
3. `routing escalate` returns correct next model
4. `routing analyze-fallbacks` shows pattern suggestions
</verification>

<success_criteria>
- Execute-plan workflow uses routing when auto profile active
- Unmatched tasks logged for future improvement
- Escalation ladder implemented (Haiku → Sonnet → Opus)
- Quota check integrated before task spawn
- Status bar updated after task completion
</success_criteria>

<output>
After completion, create `.planning/phases/01-auto-mode-foundation/01-06-SUMMARY.md`
</output>
