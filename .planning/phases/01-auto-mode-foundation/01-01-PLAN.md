---
phase: 01-auto-mode-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ~/.claude/get-shit-done/bin/gsd-tools.js
  - ~/.claude/routing-rules.md
  - .planning/routing/project-rules.md
  - .planning/config.json
autonomous: true

must_haves:
  truths:
    - "Routing rules can be defined in markdown table format"
    - "Project rules override global rules when patterns match"
    - "Rules are loaded and parsed without errors"
  artifacts:
    - path: "~/.claude/routing-rules.md"
      provides: "Global routing rules table"
      contains: "Pattern | Model | Priority"
    - path: ".planning/routing/project-rules.md"
      provides: "Project-specific routing overrides"
      contains: "Pattern | Model | Priority"
  key_links:
    - from: "gsd-tools.js"
      to: "routing-rules.md"
      via: "parseRoutingRules function"
      pattern: "loadRoutingRules|parseMarkdownTable"
---

<objective>
Create the routing rules infrastructure: markdown table format for pattern → model lookup, parser in gsd-tools.js, and project/global rule merge logic.

Purpose: Foundation for intelligent model selection based on task patterns.
Output: Routing rules files and parser ready for use by Task Context Skill.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auto-mode-foundation/01-CONTEXT.md
@.planning/phases/01-auto-mode-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create global routing rules template</name>
  <files>~/.claude/routing-rules.md</files>
  <action>
Create `~/.claude/routing-rules.md` with markdown table format:

```markdown
# Global Routing Rules

Rules for mapping task patterns to model tiers. Project rules in `.planning/routing/project-rules.md` override these.

## Rules Table

| Pattern | Model | Priority | Rationale |
|---------|-------|----------|-----------|
| architecture\|system design\|integration | opus | 3 | High-level decisions require stronger reasoning |
| planning\|roadmap\|decomposition | opus | 3 | Task breakdown needs architectural understanding |
| database schema\|migration\|index design | sonnet | 2 | Complex but well-defined data modeling |
| API endpoint\|middleware\|authentication | sonnet | 2 | Business logic implementation |
| refactor\|optimize\|improve | sonnet | 2 | Code quality decisions |
| test\|spec\|assertion | haiku | 1 | Pattern-based test generation |
| button\|styling\|CSS\|layout | haiku | 1 | Simple UI adjustments |
| documentation\|comment\|readme | haiku | 1 | Text generation, low complexity |
| typo\|rename\|format | haiku | 1 | Trivial changes |

## Priority Levels

- 3 = Opus (strongest model wins ties)
- 2 = Sonnet
- 1 = Haiku

## Adding Rules

Add new patterns as pipe-separated regex alternatives. Patterns are case-insensitive.
```

Include at least 15-20 initial patterns covering common development tasks.
  </action>
  <verify>File exists at ~/.claude/routing-rules.md with valid markdown table</verify>
  <done>Global routing rules template created with starter patterns</done>
</task>

<task type="auto">
  <name>Task 2: Create project routing rules scaffold</name>
  <files>.planning/routing/project-rules.md</files>
  <action>
Create `.planning/routing/` directory and `project-rules.md`:

```markdown
# Project Routing Rules

Project-specific routing rules. These override global rules in `~/.claude/routing-rules.md`.

## Rules Table

| Pattern | Model | Priority | Rationale |
|---------|-------|----------|-----------|
| # Add project-specific patterns here | | | |

## Usage

1. Add patterns specific to this project's domain
2. Patterns match against task descriptions (case-insensitive)
3. Higher priority wins when multiple patterns match
4. Project rules take precedence over global rules for same patterns
```

This is a scaffold — project-specific rules will be added later via session scanning or manually.
  </action>
  <verify>File exists at .planning/routing/project-rules.md</verify>
  <done>Project routing rules scaffold created</done>
</task>

<task type="auto">
  <name>Task 3: Add routing rules parser to gsd-tools.js</name>
  <files>~/.claude/get-shit-done/bin/gsd-tools.js</files>
  <action>
Add functions to gsd-tools.js for loading and merging routing rules:

1. `loadRoutingRules(filePath)` — Parse markdown table from file, return array of rule objects:
   ```javascript
   function loadRoutingRules(filePath) {
     const content = safeReadFile(filePath);
     if (!content) return [];

     const lines = content.split('\n').filter(l => l.trim() && !l.startsWith('#'));
     // Find table rows (lines starting with |)
     const tableRows = lines.filter(l => l.trim().startsWith('|'));
     // Skip header and separator
     const dataRows = tableRows.slice(2);

     return dataRows.map(line => {
       const cells = line.split('|').map(c => c.trim()).filter(Boolean);
       if (cells.length < 3) return null;
       return {
         pattern: cells[0],
         model: cells[1].toLowerCase(),
         priority: parseInt(cells[2]) || 1,
         rationale: cells[3] || ''
       };
     }).filter(Boolean);
   }
   ```

2. `mergeRoutingRules(globalRules, projectRules)` — Combine rules, project overrides global for same patterns:
   ```javascript
   function mergeRoutingRules(globalRules, projectRules) {
     const merged = [...globalRules];
     for (const rule of projectRules) {
       const existingIdx = merged.findIndex(r => r.pattern === rule.pattern);
       if (existingIdx >= 0) {
         merged[existingIdx] = rule; // Project overrides
       } else {
         merged.push(rule);
       }
     }
     return merged;
   }
   ```

3. `selectModelFromRules(taskDescription, rules)` — Match task against rules, return model:
   ```javascript
   function selectModelFromRules(taskDescription, rules) {
     const matches = rules.filter(rule => {
       try {
         return new RegExp(rule.pattern, 'i').test(taskDescription);
       } catch {
         return false;
       }
     });

     if (matches.length === 0) {
       return { model: 'sonnet', reason: 'default (no pattern match)', matched: false };
     }

     // Highest priority wins (stronger model = safer)
     const selected = matches.sort((a, b) => b.priority - a.priority)[0];
     return {
       model: selected.model,
       reason: selected.rationale,
       matched: true,
       pattern: selected.pattern
     };
   }
   ```

4. Add CLI command `routing match <task-description>` for testing:
   ```javascript
   // In command dispatch
   if (command === 'routing' && subCommand === 'match') {
     const taskDesc = args.slice(2).join(' ');
     const globalRules = loadRoutingRules(path.join(HOME, '.claude', 'routing-rules.md'));
     const projectRules = loadRoutingRules(path.join(cwd, '.planning', 'routing', 'project-rules.md'));
     const merged = mergeRoutingRules(globalRules, projectRules);
     const result = selectModelFromRules(taskDesc, merged);
     console.log(JSON.stringify(result, null, 2));
   }
   ```

Export the helper functions for use by other parts of the system.
  </action>
  <verify>
Run: `node ~/.claude/get-shit-done/bin/gsd-tools.js routing match "Create database migration for users table"`
Should return JSON with model: "sonnet" (matching database|migration pattern)
  </verify>
  <done>
Routing rules parser works:
- Loads rules from markdown tables
- Merges project rules over global rules
- Matches task descriptions against patterns
- Returns strongest model on tie
  </done>
</task>

</tasks>

<verification>
1. `cat ~/.claude/routing-rules.md` shows valid markdown table with 15+ patterns
2. `cat .planning/routing/project-rules.md` shows scaffold structure
3. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing match "Add button to dashboard"` returns haiku
4. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing match "Design system architecture"` returns opus
5. `node ~/.claude/get-shit-done/bin/gsd-tools.js routing match "unknown task type"` returns sonnet (default)
</verification>

<success_criteria>
- Routing rules stored in human-editable markdown format
- Parser handles edge cases (empty lines, malformed rows, regex errors)
- Project rules override global rules for same patterns
- Default to sonnet when no patterns match
- CLI command available for testing rule matching
</success_criteria>

<output>
After completion, create `.planning/phases/01-auto-mode-foundation/01-01-SUMMARY.md`
</output>
