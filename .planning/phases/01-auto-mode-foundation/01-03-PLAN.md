---
phase: 01-auto-mode-foundation
plan: 03
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - ~/.claude/get-shit-done/bin/gsd-tools.js
  - .planning/quota/session-usage.json
  - .planning/config.json
autonomous: true

must_haves:
  truths:
    - "Token usage tracked per task execution"
    - "80% quota warning displays before reaching limit"
    - "At 98% quota, system auto-waits for reset"
    - "Both session and weekly quotas are tracked"
  artifacts:
    - path: ".planning/quota/session-usage.json"
      provides: "Token usage tracking data"
      contains: "tokens_used"
    - path: "~/.claude/get-shit-done/bin/gsd-tools.js"
      provides: "Quota tracking and auto-wait functions"
      exports: ["trackQuota", "checkQuotaAndWait"]
  key_links:
    - from: "gsd-tools.js"
      to: "session-usage.json"
      via: "quota tracking write"
      pattern: "writeQuotaState|trackQuota"
---

<objective>
Implement quota and token tracking with auto-wait functionality for autonomous execution.

Purpose: Prevent quota exhaustion while maintaining autonomous execution by auto-sleeping and resuming.
Output: Quota tracking commands and auto-wait logic ready for sub-coordinator integration.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auto-mode-foundation/01-CONTEXT.md
@.planning/phases/01-auto-mode-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quota tracking data structure and storage</name>
  <files>.planning/quota/session-usage.json, ~/.claude/get-shit-done/bin/gsd-tools.js</files>
  <action>
1. Create `.planning/quota/` directory scaffold.

2. Add quota state structure in gsd-tools.js:
   ```javascript
   const DEFAULT_QUOTA_STATE = {
     session: {
       tokens_used: 0,
       tokens_limit: 2000000, // Default ITPM limit
       reset_time: null,
       last_updated: null
     },
     weekly: {
       tokens_used: 0,
       tokens_limit: 100000000, // Default weekly estimate
       reset_time: null,
       last_updated: null
     },
     tasks: [],  // Array of { task_id, model, tokens_in, tokens_out, timestamp }
     warnings_shown: {
       session_80: false,
       weekly_80: false
     }
   };
   ```

3. Add quota file I/O functions:
   ```javascript
   function getQuotaPath(cwd) {
     return path.join(cwd, '.planning', 'quota', 'session-usage.json');
   }

   function loadQuotaState(cwd) {
     const quotaPath = getQuotaPath(cwd);
     if (!fs.existsSync(quotaPath)) {
       return { ...DEFAULT_QUOTA_STATE };
     }
     try {
       return JSON.parse(fs.readFileSync(quotaPath, 'utf-8'));
     } catch {
       return { ...DEFAULT_QUOTA_STATE };
     }
   }

   function saveQuotaState(cwd, state) {
     const quotaPath = getQuotaPath(cwd);
     fs.mkdirSync(path.dirname(quotaPath), { recursive: true });
     fs.writeFileSync(quotaPath, JSON.stringify(state, null, 2));
   }
   ```

4. Add CLI command `quota status`:
   ```javascript
   if (command === 'quota' && subCommand === 'status') {
     const state = loadQuotaState(cwd);
     const sessionPercent = state.session.tokens_limit > 0
       ? ((state.session.tokens_used / state.session.tokens_limit) * 100).toFixed(1)
       : 0;
     const weeklyPercent = state.weekly.tokens_limit > 0
       ? ((state.weekly.tokens_used / state.weekly.tokens_limit) * 100).toFixed(1)
       : 0;

     console.log(JSON.stringify({
       session: {
         used: state.session.tokens_used,
         limit: state.session.tokens_limit,
         percent: parseFloat(sessionPercent),
         reset_time: state.session.reset_time
       },
       weekly: {
         used: state.weekly.tokens_used,
         limit: state.weekly.tokens_limit,
         percent: parseFloat(weeklyPercent),
         reset_time: state.weekly.reset_time
       },
       task_count: state.tasks.length
     }, null, 2));
   }
   ```

5. Add CLI command `quota reset`:
   ```javascript
   if (command === 'quota' && subCommand === 'reset') {
     saveQuotaState(cwd, { ...DEFAULT_QUOTA_STATE });
     console.log(JSON.stringify({ reset: true }));
   }
   ```
  </action>
  <verify>
Run:
1. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota status`
2. `ls .planning/quota/` shows directory exists
  </verify>
  <done>
Quota state structure created:
- Session and weekly tracking
- Task-level token recording
- Warning state tracking
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement quota tracking and recording</name>
  <files>~/.claude/get-shit-done/bin/gsd-tools.js</files>
  <action>
Add functions for tracking quota from API response headers and recording task usage:

1. `parseQuotaHeaders(headers)` — Extract quota info from response headers:
   ```javascript
   function parseQuotaHeaders(headers) {
     // Headers from Claude API (as documented)
     // Note: In practice, headers may come as object or need parsing
     return {
       input: {
         remaining: parseInt(headers['anthropic-ratelimit-input-tokens-remaining'] || '0'),
         limit: parseInt(headers['anthropic-ratelimit-input-tokens-limit'] || '2000000'),
         reset: headers['anthropic-ratelimit-input-tokens-reset'] || null
       },
       output: {
         remaining: parseInt(headers['anthropic-ratelimit-output-tokens-remaining'] || '0'),
         limit: parseInt(headers['anthropic-ratelimit-output-tokens-limit'] || '500000'),
         reset: headers['anthropic-ratelimit-output-tokens-reset'] || null
       }
     };
   }
   ```

2. `recordTaskUsage(cwd, taskId, model, tokensIn, tokensOut)` — Record a task's token usage:
   ```javascript
   function recordTaskUsage(cwd, taskId, model, tokensIn, tokensOut) {
     const state = loadQuotaState(cwd);

     // Add to tasks array
     state.tasks.push({
       task_id: taskId,
       model: model,
       tokens_in: tokensIn,
       tokens_out: tokensOut,
       timestamp: new Date().toISOString()
     });

     // Update session totals
     state.session.tokens_used += tokensIn + tokensOut;
     state.session.last_updated = new Date().toISOString();

     // Update weekly totals
     state.weekly.tokens_used += tokensIn + tokensOut;
     state.weekly.last_updated = new Date().toISOString();

     saveQuotaState(cwd, state);
     return state;
   }
   ```

3. CLI command `quota record <task-id> <model> <tokens-in> <tokens-out>`:
   ```javascript
   if (command === 'quota' && subCommand === 'record') {
     const [taskId, model, tokensIn, tokensOut] = args.slice(2);
     const state = recordTaskUsage(cwd, taskId, model, parseInt(tokensIn), parseInt(tokensOut));
     console.log(JSON.stringify({
       recorded: true,
       session_total: state.session.tokens_used,
       task_count: state.tasks.length
     }));
   }
   ```

4. CLI command `quota update-from-headers <json-headers>`:
   ```javascript
   if (command === 'quota' && subCommand === 'update-from-headers') {
     const headersJson = args.slice(2).join(' ');
     const headers = JSON.parse(headersJson);
     const parsed = parseQuotaHeaders(headers);

     const state = loadQuotaState(cwd);

     // Update limits and reset times from actual API headers
     state.session.tokens_limit = parsed.input.limit;
     state.session.reset_time = parsed.input.reset;
     state.session.tokens_used = parsed.input.limit - parsed.input.remaining;

     saveQuotaState(cwd, state);
     console.log(JSON.stringify({
       updated: true,
       session_percent: ((state.session.tokens_used / state.session.tokens_limit) * 100).toFixed(1)
     }));
   }
   ```
  </action>
  <verify>
Run:
1. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota record task-001 sonnet 5000 2000`
2. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota status` shows updated totals
3. `cat .planning/quota/session-usage.json` shows task record
  </verify>
  <done>
Quota tracking implemented:
- Parse API response headers
- Record task-level usage
- Update session and weekly totals
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement quota warning and auto-wait logic</name>
  <files>~/.claude/get-shit-done/bin/gsd-tools.js</files>
  <action>
Add warning and auto-wait functionality per user decisions:

1. `checkQuotaWarning(cwd)` — Check if warnings should display:
   ```javascript
   function checkQuotaWarning(cwd) {
     const state = loadQuotaState(cwd);
     const warnings = [];

     const sessionPercent = state.session.tokens_limit > 0
       ? (state.session.tokens_used / state.session.tokens_limit) * 100
       : 0;
     const weeklyPercent = state.weekly.tokens_limit > 0
       ? (state.weekly.tokens_used / state.weekly.tokens_limit) * 100
       : 0;

     // 80% session warning (only show once per session)
     if (sessionPercent >= 80 && !state.warnings_shown.session_80) {
       warnings.push({
         type: 'session',
         level: 'warning',
         message: `Session quota at ${sessionPercent.toFixed(1)}%`,
         percent: sessionPercent
       });
       state.warnings_shown.session_80 = true;
       saveQuotaState(cwd, state);
     }

     // 80% weekly warning
     if (weeklyPercent >= 80 && !state.warnings_shown.weekly_80) {
       warnings.push({
         type: 'weekly',
         level: 'warning',
         message: `Weekly quota at ${weeklyPercent.toFixed(1)}%`,
         percent: weeklyPercent
       });
       state.warnings_shown.weekly_80 = true;
       saveQuotaState(cwd, state);
     }

     return warnings;
   }
   ```

2. `checkQuotaAndWait(cwd)` — Check if auto-wait needed (98-99% threshold):
   ```javascript
   function checkQuotaAndWait(cwd) {
     const state = loadQuotaState(cwd);

     const sessionPercent = state.session.tokens_limit > 0
       ? (state.session.tokens_used / state.session.tokens_limit) * 100
       : 0;
     const weeklyPercent = state.weekly.tokens_limit > 0
       ? (state.weekly.tokens_used / state.weekly.tokens_limit) * 100
       : 0;

     const result = {
       should_wait: false,
       wait_type: null,
       wait_until: null,
       wait_seconds: 0,
       percent: 0
     };

     // Check session quota (98-99% threshold per user decision)
     if (sessionPercent >= 98 && state.session.reset_time) {
       const resetTime = new Date(state.session.reset_time);
       const waitMs = Math.max(0, resetTime.getTime() - Date.now());
       result.should_wait = true;
       result.wait_type = 'session';
       result.wait_until = state.session.reset_time;
       result.wait_seconds = Math.ceil(waitMs / 1000) + 5; // +5s buffer
       result.percent = sessionPercent;
     }

     // Check weekly quota
     if (weeklyPercent >= 98 && state.weekly.reset_time) {
       const resetTime = new Date(state.weekly.reset_time);
       const waitMs = Math.max(0, resetTime.getTime() - Date.now());
       // If weekly wait is longer than session wait, use weekly
       if (!result.should_wait || waitMs > result.wait_seconds * 1000) {
         result.should_wait = true;
         result.wait_type = 'weekly';
         result.wait_until = state.weekly.reset_time;
         result.wait_seconds = Math.ceil(waitMs / 1000) + 5;
         result.percent = weeklyPercent;
       }
     }

     return result;
   }
   ```

3. CLI command `quota check`:
   ```javascript
   if (command === 'quota' && subCommand === 'check') {
     const warnings = checkQuotaWarning(cwd);
     const waitCheck = checkQuotaAndWait(cwd);

     console.log(JSON.stringify({
       warnings,
       wait: waitCheck
     }, null, 2));
   }
   ```

4. CLI command `quota wait` — Execute auto-wait if needed:
   ```javascript
   if (command === 'quota' && subCommand === 'wait') {
     const waitCheck = checkQuotaAndWait(cwd);

     if (!waitCheck.should_wait) {
       console.log(JSON.stringify({ waited: false, reason: 'quota_ok' }));
       return;
     }

     console.log(JSON.stringify({
       waiting: true,
       type: waitCheck.wait_type,
       seconds: waitCheck.wait_seconds,
       until: waitCheck.wait_until
     }));

     // Note: Actual sleep must be handled by caller (shell/coordinator)
     // This command returns the wait info for the caller to act on
   }
   ```
  </action>
  <verify>
Run:
1. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota check` shows warnings and wait status
2. Manually set high usage in session-usage.json, verify warning triggers
  </verify>
  <done>
Quota warning and auto-wait logic:
- 80% soft warning (once per session)
- 98% auto-wait calculation
- Returns wait duration for coordinator
- Tracks both session and weekly quotas
  </done>
</task>

</tasks>

<verification>
1. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota status` returns valid JSON
2. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota record task-001 haiku 1000 500` records task
3. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota check` returns warnings/wait info
4. `cat .planning/quota/session-usage.json` shows recorded tasks and totals
5. `node ~/.claude/get-shit-done/bin/gsd-tools.js quota reset` clears state
</verification>

<success_criteria>
- Token usage tracked per task with model info
- 80% warning triggers once per session
- 98% threshold triggers auto-wait calculation
- Both session and weekly quotas tracked independently
- CLI commands available for coordinator integration
</success_criteria>

<output>
After completion, create `.planning/phases/01-auto-mode-foundation/01-03-SUMMARY.md`
</output>
