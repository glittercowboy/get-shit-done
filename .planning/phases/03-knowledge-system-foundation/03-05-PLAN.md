---
phase: 03-knowledge-system-foundation
plan: 05
type: execute
wave: 4
depends_on: ["03-02", "03-03", "03-04"]
files_modified:
  - get-shit-done/bin/knowledge.js
  - get-shit-done/bin/gsd-tools.js
autonomous: true

must_haves:
  truths:
    - "Unified knowledge API provides all operations through single module"
    - "gsd-tools has knowledge commands for CLI access"
    - "Fallback behavior skips knowledge features when DB unavailable"
    - "Both global and project scopes accessible via API"
    - "Cleanup runs automatically on database open"
  artifacts:
    - path: "get-shit-done/bin/knowledge.js"
      provides: "Unified knowledge API facade"
      min_lines: 100
      exports: ["knowledge"]
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "CLI commands for knowledge operations"
      contains: "cmdKnowledge"
  key_links:
    - from: "get-shit-done/bin/knowledge.js"
      to: "get-shit-done/bin/knowledge-db.js"
      via: "require"
      pattern: "require.*knowledge-db"
    - from: "get-shit-done/bin/knowledge.js"
      to: "get-shit-done/bin/knowledge-crud.js"
      via: "require"
      pattern: "require.*knowledge-crud"
    - from: "get-shit-done/bin/knowledge.js"
      to: "get-shit-done/bin/knowledge-search.js"
      via: "require"
      pattern: "require.*knowledge-search"
    - from: "get-shit-done/bin/knowledge.js"
      to: "get-shit-done/bin/knowledge-lifecycle.js"
      via: "require"
      pattern: "require.*knowledge-lifecycle"
---

<objective>
Create unified knowledge API and integrate with gsd-tools CLI for full knowledge system access.

Purpose: Provide a clean facade over the knowledge modules and expose CLI commands for testing, debugging, and direct knowledge manipulation.

Output: `knowledge.js` facade module and gsd-tools CLI commands.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-knowledge-system-foundation/03-RESEARCH.md
@.planning/phases/03-knowledge-system-foundation/03-02-SUMMARY.md
@.planning/phases/03-knowledge-system-foundation/03-03-SUMMARY.md
@.planning/phases/03-knowledge-system-foundation/03-04-SUMMARY.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unified knowledge.js facade</name>
  <files>get-shit-done/bin/knowledge.js</files>
  <action>
Create new file `get-shit-done/bin/knowledge.js` implementing a unified API:

```javascript
#!/usr/bin/env node

/**
 * Knowledge System API
 *
 * Unified facade for GSD knowledge operations. Provides high-level
 * access to storage, search, and lifecycle management.
 *
 * Usage:
 *   const knowledge = require('./knowledge.js');
 *   const result = knowledge.search('SQLite patterns', { scope: 'project' });
 */

const path = require('path');

// ─── Lazy Loading ────────────────────────────────────────────────────────────

let db = null;
let crud = null;
let search = null;
let lifecycle = null;

function loadModules() {
  if (!db) {
    try {
      db = require('./knowledge-db.js');
      crud = require('./knowledge-crud.js');
      search = require('./knowledge-search.js');
      lifecycle = require('./knowledge-lifecycle.js');
    } catch (err) {
      return { available: false, reason: err.message };
    }
  }
  return { available: true };
}

// ─── Connection Cache ────────────────────────────────────────────────────────

const connections = new Map();

function getConnection(scope) {
  const check = loadModules();
  if (!check.available) {
    return { db: null, available: false, reason: check.reason };
  }

  const available = db.isKnowledgeDBAvailable(scope);
  if (!available.available) {
    return { db: null, available: false, reason: available.reason };
  }

  const dbPath = db.getDBPath(scope);
  if (!connections.has(dbPath)) {
    const conn = db.openKnowledgeDB(scope);
    connections.set(dbPath, conn);

    // Run cleanup on first open
    const cleaned = lifecycle.cleanupExpired(conn);
    if (cleaned.deleted > 0) {
      console.log(`Knowledge: cleaned ${cleaned.deleted} expired entries`);
    }
  }

  return { db: connections.get(dbPath), available: true };
}

function closeAllConnections() {
  const check = loadModules();
  if (!check.available) return;

  for (const conn of connections.values()) {
    db.closeKnowledgeDB(conn);
  }
  connections.clear();
}

// ─── High-Level API ──────────────────────────────────────────────────────────

const knowledge = {
  /**
   * Check if knowledge system is available
   * @param {string} scope - 'global' or 'project'
   * @returns {{ available: boolean, reason?: string }}
   */
  isAvailable(scope = 'project') {
    const check = loadModules();
    if (!check.available) return check;
    return db.isKnowledgeDBAvailable(scope);
  },

  /**
   * Add knowledge entry
   * @param {Object} entry - { content, type, scope, ttlCategory?, embedding?, metadata? }
   * @returns {{ id: number, content_hash: string } | { skipped: true, reason: string }}
   */
  add(entry) {
    const conn = getConnection(entry.scope || 'project');
    if (!conn.available) {
      return { skipped: true, reason: conn.reason };
    }
    return crud.insertKnowledge(conn.db, entry);
  },

  /**
   * Get knowledge by ID
   * @param {number} id
   * @param {string} scope - 'global' or 'project'
   * @returns {Object | null}
   */
  get(id, scope = 'project') {
    const conn = getConnection(scope);
    if (!conn.available) return null;

    const result = crud.getKnowledge(conn.db, id);
    if (result) {
      lifecycle.trackAccess(conn.db, id);
    }
    return result;
  },

  /**
   * Search knowledge
   * @param {string} query - Text query for FTS search
   * @param {Object} options - { scope?, types?, embedding?, limit? }
   * @returns {Array}
   */
  search(query, options = {}) {
    const scope = options.scope || 'project';
    const conn = getConnection(scope);
    if (!conn.available) return [];

    const results = search.searchKnowledge(conn.db, query, options);

    // Track access for returned results
    if (results.length > 0) {
      lifecycle.trackAccessBatch(conn.db, results.map(r => r.id));
    }

    return results;
  },

  /**
   * Update knowledge entry
   * @param {number} id
   * @param {Object} updates - { content?, type?, ttlCategory?, metadata?, embedding? }
   * @param {string} scope
   * @returns {{ success: boolean, error?: string }}
   */
  update(id, updates, scope = 'project') {
    const conn = getConnection(scope);
    if (!conn.available) {
      return { success: false, error: conn.reason };
    }
    return crud.updateKnowledge(conn.db, id, updates);
  },

  /**
   * Delete knowledge entry
   * @param {number} id
   * @param {string} scope
   * @returns {{ deleted: boolean }}
   */
  delete(id, scope = 'project') {
    const conn = getConnection(scope);
    if (!conn.available) {
      return { deleted: false };
    }
    return crud.deleteKnowledge(conn.db, id);
  },

  /**
   * Get knowledge by type
   * @param {string} type - 'decision', 'lesson', 'summary', 'temp_note'
   * @param {Object} options - { scope?, limit? }
   * @returns {Array}
   */
  getByType(type, options = {}) {
    const scope = options.scope || 'project';
    const conn = getConnection(scope);
    if (!conn.available) return [];
    return crud.getKnowledgeByType(conn.db, type, options);
  },

  /**
   * Run cleanup on expired entries
   * @param {string} scope
   * @returns {{ deleted: number, ids: number[] }}
   */
  cleanup(scope = 'project') {
    const conn = getConnection(scope);
    if (!conn.available) {
      return { deleted: 0, ids: [] };
    }
    return lifecycle.cleanupExpired(conn.db);
  },

  /**
   * Get staleness information
   * @param {number} id
   * @param {string} scope
   * @returns {Object | null}
   */
  getStaleness(id, scope = 'project') {
    const conn = getConnection(scope);
    if (!conn.available) return null;
    return lifecycle.getStalenessScore(conn.db, id);
  },

  /**
   * Get access statistics
   * @param {Object} options - { scope?, type? }
   * @returns {Array}
   */
  getStats(options = {}) {
    const scope = options.scope || 'project';
    const conn = getConnection(scope);
    if (!conn.available) return [];
    return lifecycle.getAccessStats(conn.db, options);
  },

  /**
   * Close all connections (for cleanup)
   */
  close: closeAllConnections
};

module.exports = { knowledge };
```

Follow conventions: camelCase functions, JSDoc comments, section dividers.
  </action>
  <verify>
```javascript
const { knowledge } = require('./get-shit-done/bin/knowledge.js');

// Check availability
console.log(knowledge.isAvailable('project'));

// Add knowledge
const result = knowledge.add({
  content: 'Use better-sqlite3 for SQLite access in Node.js',
  type: 'decision',
  scope: 'project'
});
console.log(result.id);

// Search
const found = knowledge.search('SQLite Node.js');
console.log(found.length);

// Cleanup
knowledge.close();
```
  </verify>
  <done>
knowledge.js provides unified API for all knowledge operations. Lazy loading defers module require until first use. Connection caching avoids repeated opens. Automatic cleanup on first open.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add knowledge commands to gsd-tools.js</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Add knowledge CLI commands to gsd-tools.js. Find the command dispatch section and add:

**New commands in JSDoc header:**
```
 * Knowledge Operations:
 *   knowledge status [--scope project|global]   Show knowledge DB status
 *   knowledge add <content> --type <type>       Add knowledge entry
 *     [--scope project|global]
 *     [--ttl permanent|long_term|short_term|ephemeral]
 *   knowledge search <query>                    Search knowledge
 *     [--scope project|global] [--limit N]
 *   knowledge get <id> [--scope project|global] Get knowledge by ID
 *   knowledge delete <id>                       Delete knowledge entry
 *     [--scope project|global]
 *   knowledge cleanup [--scope project|global]  Remove expired entries
 *   knowledge stats [--scope project|global]    Show access statistics
```

**Command implementations:**

```javascript
// ─── Knowledge Commands ──────────────────────────────────────────────────────

function cmdKnowledgeStatus(cwd, args, raw) {
  const scope = args.includes('--scope') ? args[args.indexOf('--scope') + 1] : 'project';
  const { knowledge } = require('./knowledge.js');

  const status = knowledge.isAvailable(scope);
  const result = {
    scope,
    available: status.available,
    reason: status.reason || null,
    db_path: status.available ? require('./knowledge-db.js').getDBPath(scope) : null
  };

  output(result, raw);
}

function cmdKnowledgeAdd(cwd, args, raw) {
  const content = args[0];
  if (!content) {
    error('knowledge add: content required');
  }

  const scope = args.includes('--scope') ? args[args.indexOf('--scope') + 1] : 'project';
  const type = args.includes('--type') ? args[args.indexOf('--type') + 1] : 'summary';
  const ttl = args.includes('--ttl') ? args[args.indexOf('--ttl') + 1] : null;

  const { knowledge } = require('./knowledge.js');
  const result = knowledge.add({
    content,
    type,
    scope,
    ttlCategory: ttl
  });

  output(result, raw);
}

function cmdKnowledgeSearch(cwd, args, raw) {
  const query = args[0];
  if (!query) {
    error('knowledge search: query required');
  }

  const scope = args.includes('--scope') ? args[args.indexOf('--scope') + 1] : 'project';
  const limit = args.includes('--limit') ? parseInt(args[args.indexOf('--limit') + 1]) : 10;

  const { knowledge } = require('./knowledge.js');
  const results = knowledge.search(query, { scope, limit });

  output(results, raw);
}

function cmdKnowledgeGet(cwd, args, raw) {
  const id = parseInt(args[0]);
  if (isNaN(id)) {
    error('knowledge get: id required (integer)');
  }

  const scope = args.includes('--scope') ? args[args.indexOf('--scope') + 1] : 'project';

  const { knowledge } = require('./knowledge.js');
  const result = knowledge.get(id, scope);

  output(result, raw);
}

function cmdKnowledgeDelete(cwd, args, raw) {
  const id = parseInt(args[0]);
  if (isNaN(id)) {
    error('knowledge delete: id required (integer)');
  }

  const scope = args.includes('--scope') ? args[args.indexOf('--scope') + 1] : 'project';

  const { knowledge } = require('./knowledge.js');
  const result = knowledge.delete(id, scope);

  output(result, raw);
}

function cmdKnowledgeCleanup(cwd, args, raw) {
  const scope = args.includes('--scope') ? args[args.indexOf('--scope') + 1] : 'project';

  const { knowledge } = require('./knowledge.js');
  const result = knowledge.cleanup(scope);

  output(result, raw);
}

function cmdKnowledgeStats(cwd, args, raw) {
  const scope = args.includes('--scope') ? args[args.indexOf('--scope') + 1] : 'project';

  const { knowledge } = require('./knowledge.js');
  const result = knowledge.getStats({ scope });

  output(result, raw);
}
```

**Add to command dispatch switch:**
```javascript
case 'knowledge':
  const knowledgeSubcmd = args[1];
  const knowledgeArgs = args.slice(2);
  switch (knowledgeSubcmd) {
    case 'status':
      cmdKnowledgeStatus(cwd, knowledgeArgs, raw);
      break;
    case 'add':
      cmdKnowledgeAdd(cwd, knowledgeArgs, raw);
      break;
    case 'search':
      cmdKnowledgeSearch(cwd, knowledgeArgs, raw);
      break;
    case 'get':
      cmdKnowledgeGet(cwd, knowledgeArgs, raw);
      break;
    case 'delete':
      cmdKnowledgeDelete(cwd, knowledgeArgs, raw);
      break;
    case 'cleanup':
      cmdKnowledgeCleanup(cwd, knowledgeArgs, raw);
      break;
    case 'stats':
      cmdKnowledgeStats(cwd, knowledgeArgs, raw);
      break;
    default:
      error(`knowledge: unknown subcommand '${knowledgeSubcmd}'`);
  }
  break;
```
  </action>
  <verify>
```bash
# Test CLI commands
node get-shit-done/bin/gsd-tools.js knowledge status
node get-shit-done/bin/gsd-tools.js knowledge add "Test knowledge" --type decision
node get-shit-done/bin/gsd-tools.js knowledge search "Test"
node get-shit-done/bin/gsd-tools.js knowledge stats
node get-shit-done/bin/gsd-tools.js knowledge cleanup
```
  </verify>
  <done>
gsd-tools.js has knowledge subcommands: status, add, search, get, delete, cleanup, stats. All commands support --scope flag for global/project selection.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add fallback behavior and graceful degradation</name>
  <files>get-shit-done/bin/knowledge.js</files>
  <action>
Enhance knowledge.js with robust fallback behavior (KNOW-04):

**Add fallback wrapper:**
```javascript
/**
 * Execute knowledge operation with fallback
 * Returns null/empty if knowledge system unavailable
 */
function withFallback(fn, defaultValue = null) {
  return (...args) => {
    try {
      return fn(...args);
    } catch (err) {
      // Log but don't throw - graceful degradation
      if (process.env.GSD_DEBUG) {
        console.warn('Knowledge system error:', err.message);
      }
      return defaultValue;
    }
  };
}
```

**Add isEnabled check:**
```javascript
/**
 * Check if knowledge system is enabled in config
 * Respects config.json knowledge setting
 */
function isKnowledgeEnabled(cwd) {
  const configPath = path.join(cwd, '.planning', 'config.json');
  try {
    const config = JSON.parse(require('fs').readFileSync(configPath, 'utf-8'));
    // Default to enabled if not specified
    return config.knowledge !== false;
  } catch {
    return true; // Enabled by default
  }
}
```

**Enhance API with fallback:**
```javascript
const knowledge = {
  // ... existing methods wrapped with fallback

  /**
   * Safe search that returns empty array on any error
   */
  safeSearch(query, options = {}) {
    return withFallback(
      () => this.search(query, options),
      []
    )();
  },

  /**
   * Safe add that returns skipped status on any error
   */
  safeAdd(entry) {
    return withFallback(
      () => this.add(entry),
      { skipped: true, reason: 'knowledge system unavailable' }
    )();
  },

  /**
   * Check if knowledge is both available and enabled
   */
  isReady(scope = 'project', cwd = process.cwd()) {
    if (!isKnowledgeEnabled(cwd)) {
      return { ready: false, reason: 'disabled in config' };
    }
    const available = this.isAvailable(scope);
    return {
      ready: available.available,
      reason: available.available ? null : available.reason
    };
  }
};
```

This ensures GSD works normally even if:
- better-sqlite3 isn't installed (native compilation failed)
- sqlite-vec extension can't load (platform issue)
- Database directory is unwritable
- Config disables knowledge features
  </action>
  <verify>
```javascript
// Test fallback behavior
const { knowledge } = require('./get-shit-done/bin/knowledge.js');

// Should return gracefully even if DB not available
const results = knowledge.safeSearch('test');
console.log(Array.isArray(results)); // true

// Should indicate disabled status
const ready = knowledge.isReady('project');
console.log(ready); // { ready: bool, reason: string|null }
```
  </verify>
  <done>
Fallback behavior ensures GSD works without knowledge system. safeSearch and safeAdd never throw. isReady checks both availability and config. Config can disable knowledge with `knowledge: false`.
  </done>
</task>

</tasks>

<verification>
1. knowledge.js provides unified API facade
2. All CRUD, search, and lifecycle operations accessible
3. gsd-tools.js has knowledge subcommands
4. Fallback behavior when DB unavailable
5. Config can disable knowledge system
6. Automatic cleanup on first database open
7. Access tracking on retrieval operations
</verification>

<success_criteria>
- knowledge.js exports: { knowledge } with methods: isAvailable, add, get, search, update, delete, getByType, cleanup, getStaleness, getStats, close, safeSearch, safeAdd, isReady
- gsd-tools.js commands: knowledge status, add, search, get, delete, cleanup, stats
- All commands support --scope project|global
- Graceful degradation when dependencies unavailable
- Config option `knowledge: false` disables features
- Automatic cleanup runs on database open
</success_criteria>

<output>
After completion, create `.planning/phases/03-knowledge-system-foundation/03-05-SUMMARY.md`
</output>
