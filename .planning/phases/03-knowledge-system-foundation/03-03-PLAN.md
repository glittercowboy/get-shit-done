---
phase: 03-knowledge-system-foundation
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - get-shit-done/bin/knowledge-search.js
autonomous: true

must_haves:
  truths:
    - "Hybrid search combines FTS5 and vector results using RRF"
    - "Type weights rank decisions/lessons at 2.0x, summaries at 0.5x"
    - "Access count boosts frequently-used knowledge"
    - "Search works with vector-only, FTS-only, or hybrid mode"
    - "Empty results return gracefully without errors"
  artifacts:
    - path: "get-shit-done/bin/knowledge-search.js"
      provides: "Multi-phase search pipeline"
      min_lines: 180
      exports: ["searchKnowledge", "vectorSearch", "ftsSearch", "hybridSearch"]
  key_links:
    - from: "get-shit-done/bin/knowledge-search.js"
      to: "get-shit-done/bin/knowledge-db.js"
      via: "require"
      pattern: "require.*knowledge-db"
---

<objective>
Implement the multi-phase search pipeline with vector similarity, FTS5 text search, type weighting, and access boost.

Purpose: Enable intelligent knowledge retrieval using the hybrid search approach recommended in research (RRF fusion), with type-weighted scoring for relevance ranking.

Output: `knowledge-search.js` module with hybrid search implementation.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-knowledge-system-foundation/03-RESEARCH.md
@.planning/phases/03-knowledge-system-foundation/03-01-SUMMARY.md
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create knowledge-search.js with FTS5 search</name>
  <files>get-shit-done/bin/knowledge-search.js</files>
  <action>
Create new file `get-shit-done/bin/knowledge-search.js` implementing:

**FTS5 keyword search:**
```javascript
function ftsSearch(db, query, { limit = 20, scope = null, types = null } = {}) {
  // Build query with optional filters
  let sql = `
    SELECT
      k.id,
      k.content,
      k.type,
      k.scope,
      k.access_count,
      k.created_at,
      k.metadata,
      bm25(knowledge_fts) as bm25_score
    FROM knowledge_fts
    JOIN knowledge k ON knowledge_fts.rowid = k.id
    WHERE knowledge_fts MATCH ?
  `;

  const params = [query];

  if (scope) {
    sql += ' AND k.scope = ?';
    params.push(scope);
  }

  if (types && types.length > 0) {
    sql += ` AND k.type IN (${types.map(() => '?').join(',')})`;
    params.push(...types);
  }

  // Exclude expired entries
  sql += ' AND (k.expires_at IS NULL OR k.expires_at > ?)';
  params.push(Date.now());

  sql += ' ORDER BY bm25_score LIMIT ?';
  params.push(limit);

  try {
    return db.prepare(sql).all(...params).map((row, idx) => ({
      ...row,
      fts_rank: idx + 1,
      metadata: row.metadata ? JSON.parse(row.metadata) : {}
    }));
  } catch (err) {
    // FTS5 MATCH can throw on malformed queries
    if (err.message.includes('fts5')) {
      return [];
    }
    throw err;
  }
}
```

**Query sanitization:**
FTS5 MATCH syntax requires escaping special characters:
```javascript
function sanitizeFTSQuery(query) {
  // Escape special FTS5 characters
  return query
    .replace(/[(){}[\]^"~*?:\\]/g, ' ')
    .trim()
    .split(/\s+/)
    .filter(word => word.length > 0)
    .join(' ');
}
```

Handle empty queries and FTS5 errors gracefully.
  </action>
  <verify>
```javascript
const { openKnowledgeDB, closeKnowledgeDB } = require('./get-shit-done/bin/knowledge-db.js');
const { insertKnowledge } = require('./get-shit-done/bin/knowledge-crud.js');
const { ftsSearch } = require('./get-shit-done/bin/knowledge-search.js');

const db = openKnowledgeDB('project');
insertKnowledge(db, { content: 'Use SQLite for local storage', type: 'decision', scope: 'project', ttlCategory: 'long_term' });
insertKnowledge(db, { content: 'PostgreSQL is good for production', type: 'decision', scope: 'project', ttlCategory: 'long_term' });

const results = ftsSearch(db, 'SQLite storage');
console.log(results.length); // 1
console.log(results[0].content); // 'Use SQLite for local storage'
closeKnowledgeDB(db);
```
  </verify>
  <done>
ftsSearch returns BM25-ranked results with scope/type filtering and expired entry exclusion.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add vector similarity search</name>
  <files>get-shit-done/bin/knowledge-search.js</files>
  <action>
Add vector search function:

**Vector similarity search:**
```javascript
function vectorSearch(db, embedding, { limit = 20, scope = null, types = null } = {}) {
  if (!db.vectorEnabled) {
    return []; // Gracefully degrade if sqlite-vec not available
  }

  // Normalize query embedding
  const normalizedEmb = normalizeEmbedding(embedding);

  // Base vector query
  let sql = `
    SELECT
      k.id,
      k.content,
      k.type,
      k.scope,
      k.access_count,
      k.created_at,
      k.metadata,
      vec.distance as vec_distance
    FROM knowledge_vec vec
    JOIN knowledge k ON vec.rowid = k.id
    WHERE vec.embedding MATCH ?
      AND k.id > 0
  `;

  const params = [normalizedEmb];

  if (scope) {
    sql += ' AND k.scope = ?';
    params.push(scope);
  }

  if (types && types.length > 0) {
    sql += ` AND k.type IN (${types.map(() => '?').join(',')})`;
    params.push(...types);
  }

  // Exclude expired entries
  sql += ' AND (k.expires_at IS NULL OR k.expires_at > ?)';
  params.push(Date.now());

  sql += ' ORDER BY vec.distance LIMIT ?';
  params.push(limit);

  return db.prepare(sql).all(...params).map((row, idx) => ({
    ...row,
    vec_rank: idx + 1,
    metadata: row.metadata ? JSON.parse(row.metadata) : {}
  }));
}
```

**Normalization helper (shared with crud):**
```javascript
function normalizeEmbedding(embedding) {
  const arr = embedding instanceof Float32Array ? embedding : new Float32Array(embedding);
  const norm = Math.sqrt(arr.reduce((sum, val) => sum + val * val, 0));
  if (norm < 1e-12) return arr;
  return new Float32Array(arr.map(v => v / norm));
}
```

Note: cosine distance in sqlite-vec is 0 = identical, 2 = opposite.
  </action>
  <verify>
```javascript
// Create test embedding (512 dims)
const testEmb = new Float32Array(512).fill(0.1);
insertKnowledge(db, {
  content: 'Test with embedding',
  type: 'decision',
  scope: 'project',
  ttlCategory: 'long_term',
  embedding: testEmb
});

const results = vectorSearch(db, testEmb, { limit: 5 });
console.log(results.length); // 1
console.log(results[0].vec_distance); // ~0 (very similar)
```
  </verify>
  <done>
vectorSearch returns distance-ranked results with graceful degradation when sqlite-vec unavailable.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement hybrid search with RRF and type weights</name>
  <files>get-shit-done/bin/knowledge-search.js</files>
  <action>
Implement the main hybrid search function combining FTS5 and vector with RRF fusion:

**Type weights (per KNOW-07):**
```javascript
const TYPE_WEIGHTS = {
  decision: 2.0,
  lesson: 2.0,
  summary: 0.5,
  temp_note: 0.3
};
```

**Reciprocal Rank Fusion (RRF):**
```javascript
function hybridSearch(db, {
  query = null,           // Text query for FTS5
  embedding = null,       // Vector embedding for similarity
  limit = 10,
  scope = null,
  types = null,
  k = 60                  // RRF constant (standard value)
} = {}) {
  const candidateLimit = limit * 3; // Fetch more candidates for fusion

  // Phase 1: Gather candidates from both sources
  const ftsResults = query ? ftsSearch(db, query, { limit: candidateLimit, scope, types }) : [];
  const vecResults = embedding ? vectorSearch(db, embedding, { limit: candidateLimit, scope, types }) : [];

  // Phase 2: Build RRF score map
  const scoreMap = new Map();

  for (const row of ftsResults) {
    scoreMap.set(row.id, {
      id: row.id,
      content: row.content,
      type: row.type,
      scope: row.scope,
      access_count: row.access_count,
      created_at: row.created_at,
      metadata: row.metadata,
      rrf_score: 1 / (k + row.fts_rank),
      sources: ['fts']
    });
  }

  for (const row of vecResults) {
    const existing = scoreMap.get(row.id);
    const rrfScore = 1 / (k + row.vec_rank);

    if (existing) {
      existing.rrf_score += rrfScore;
      existing.sources.push('vec');
    } else {
      scoreMap.set(row.id, {
        id: row.id,
        content: row.content,
        type: row.type,
        scope: row.scope,
        access_count: row.access_count,
        created_at: row.created_at,
        metadata: row.metadata,
        rrf_score: rrfScore,
        sources: ['vec']
      });
    }
  }

  // Phase 3: Apply type weights and access boost
  const results = Array.from(scoreMap.values())
    .map(entry => {
      const typeWeight = TYPE_WEIGHTS[entry.type] || 1.0;
      const accessBoost = 1 + Math.log(1 + entry.access_count);
      return {
        ...entry,
        type_weight: typeWeight,
        access_boost: accessBoost,
        final_score: entry.rrf_score * typeWeight * accessBoost
      };
    })
    .sort((a, b) => b.final_score - a.final_score)
    .slice(0, limit);

  return results;
}
```

**Main search function (convenience wrapper):**
```javascript
function searchKnowledge(db, query, options = {}) {
  // If query is string, use FTS
  // If embedding provided, include vector search
  // Returns hybrid results with scoring metadata
  return hybridSearch(db, {
    query: typeof query === 'string' ? query : null,
    embedding: options.embedding || null,
    limit: options.limit || 10,
    scope: options.scope || null,
    types: options.types || null
  });
}
```

Export: `{ searchKnowledge, ftsSearch, vectorSearch, hybridSearch, TYPE_WEIGHTS }`
  </action>
  <verify>
```javascript
const results = hybridSearch(db, {
  query: 'SQLite',
  embedding: testEmb,
  limit: 5
});
console.log(results[0].sources); // ['fts', 'vec'] if matches both
console.log(results[0].final_score); // Combined score with type weight
console.log(results[0].type_weight); // 2.0 for decisions
```
  </verify>
  <done>
hybridSearch combines FTS5 and vector results using RRF with k=60. Type weights applied (decisions/lessons 2.0x, summaries 0.5x). Access boost uses logarithmic scale. Final scores include all factors.
  </done>
</task>

</tasks>

<verification>
1. ftsSearch returns BM25-ranked results
2. vectorSearch returns distance-ranked results (lower = more similar)
3. hybridSearch combines both with RRF (k=60)
4. Type weights: decision=2.0, lesson=2.0, summary=0.5, temp_note=0.3
5. Access boost: 1 + log(1 + access_count)
6. Expired entries excluded from all searches
7. Empty queries/embeddings handled gracefully
</verification>

<success_criteria>
- knowledge-search.js exports: searchKnowledge, ftsSearch, vectorSearch, hybridSearch, TYPE_WEIGHTS
- FTS5 search with BM25 ranking and query sanitization
- Vector search with cosine distance and normalization
- RRF fusion with k=60 combining FTS and vector ranks
- Type weights match KNOW-07 requirements
- Access count provides logarithmic boost per KNOW-11
- Graceful degradation when vector search unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/03-knowledge-system-foundation/03-03-SUMMARY.md`
</output>
