---
phase: 03-knowledge-system-foundation
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - get-shit-done/bin/knowledge-lifecycle.js
autonomous: true

must_haves:
  truths:
    - "Expired knowledge is automatically cleaned up"
    - "Access tracking updates count and timestamp on retrieval"
    - "Staleness tracking includes volatility scores"
    - "Cleanup runs without blocking main operations"
    - "WAL checkpointing occurs after large cleanup operations"
  artifacts:
    - path: "get-shit-done/bin/knowledge-lifecycle.js"
      provides: "TTL cleanup, access tracking, staleness management"
      min_lines: 120
      exports: ["cleanupExpired", "trackAccess", "getStalenessScore", "checkpointWAL"]
  key_links:
    - from: "get-shit-done/bin/knowledge-lifecycle.js"
      to: "get-shit-done/bin/knowledge-db.js"
      via: "require"
      pattern: "require.*knowledge-db"
---

<objective>
Implement TTL-based lifecycle management with automatic cleanup, access tracking, and staleness scoring.

Purpose: Maintain knowledge freshness by removing expired entries, tracking access patterns for relevance boosting, and providing staleness indicators for knowledge quality assessment.

Output: `knowledge-lifecycle.js` module with lifecycle management functions.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-knowledge-system-foundation/03-RESEARCH.md
@.planning/phases/03-knowledge-system-foundation/03-02-SUMMARY.md
@.planning/phases/03-knowledge-system-foundation/03-03-SUMMARY.md
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TTL cleanup with atomic transactions</name>
  <files>get-shit-done/bin/knowledge-lifecycle.js</files>
  <action>
Create new file `get-shit-done/bin/knowledge-lifecycle.js` implementing:

**Cleanup expired knowledge (KNOW-09):**
```javascript
function cleanupExpired(db) {
  const now = Date.now();

  const deleted = db.transaction(() => {
    // First, get IDs to delete (for vector cleanup)
    const expiredIds = db.prepare(`
      SELECT id FROM knowledge
      WHERE expires_at IS NOT NULL AND expires_at < ?
    `).all(now).map(row => row.id);

    if (expiredIds.length === 0) {
      return { deleted: 0, ids: [] };
    }

    // Delete from vector table (FTS5 handled by trigger)
    if (db.vectorEnabled) {
      const placeholders = expiredIds.map(() => '?').join(',');
      db.prepare(`DELETE FROM knowledge_vec WHERE rowid IN (${placeholders})`).run(...expiredIds);
    }

    // Delete from main table (triggers FTS5 cleanup)
    const result = db.prepare(`
      DELETE FROM knowledge
      WHERE expires_at IS NOT NULL AND expires_at < ?
    `).run(now);

    return { deleted: result.changes, ids: expiredIds };
  })();

  // Checkpoint WAL after large deletions
  if (deleted.deleted > 100) {
    checkpointWAL(db);
  }

  return deleted;
}
```

**WAL checkpointing:**
```javascript
function checkpointWAL(db) {
  try {
    db.pragma('wal_checkpoint(TRUNCATE)');
    return { success: true };
  } catch (err) {
    return { success: false, error: err.message };
  }
}
```

**Scheduled cleanup helper:**
```javascript
function scheduleCleanup(db, intervalMs = 24 * 60 * 60 * 1000) {
  // For CLI tools, cleanup runs on startup rather than daemon-style
  // This function is for future daemon mode
  const cleanup = () => {
    const result = cleanupExpired(db);
    if (result.deleted > 0) {
      console.log(`Knowledge cleanup: removed ${result.deleted} expired entries`);
    }
  };

  return setInterval(cleanup, intervalMs);
}
```

Per research: Always use transactions for multi-table cleanup to avoid orphaned entries.
  </action>
  <verify>
```javascript
const { openKnowledgeDB, closeKnowledgeDB } = require('./get-shit-done/bin/knowledge-db.js');
const { insertKnowledge } = require('./get-shit-done/bin/knowledge-crud.js');
const { cleanupExpired } = require('./get-shit-done/bin/knowledge-lifecycle.js');

const db = openKnowledgeDB('project');

// Insert ephemeral entry that expires in 1ms
insertKnowledge(db, {
  content: 'Expires immediately',
  type: 'temp_note',
  scope: 'project',
  ttlCategory: 'ephemeral'
});

// Manually set expires_at to past
db.prepare('UPDATE knowledge SET expires_at = ? WHERE id = 1').run(Date.now() - 1000);

const result = cleanupExpired(db);
console.log(result.deleted); // 1
closeKnowledgeDB(db);
```
  </verify>
  <done>
cleanupExpired removes all expired entries atomically. WAL checkpointing runs after large cleanups.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement access tracking</name>
  <files>get-shit-done/bin/knowledge-lifecycle.js</files>
  <action>
Add access tracking functions (KNOW-11):

**Track access on retrieval:**
```javascript
function trackAccess(db, knowledgeId) {
  const now = Date.now();

  const result = db.prepare(`
    UPDATE knowledge
    SET access_count = access_count + 1,
        last_accessed = ?
    WHERE id = ?
  `).run(now, knowledgeId);

  return { updated: result.changes > 0 };
}
```

**Batch access tracking:**
```javascript
function trackAccessBatch(db, knowledgeIds) {
  if (knowledgeIds.length === 0) return { updated: 0 };

  const now = Date.now();

  const updated = db.transaction(() => {
    const stmt = db.prepare(`
      UPDATE knowledge
      SET access_count = access_count + 1,
          last_accessed = ?
      WHERE id = ?
    `);

    let count = 0;
    for (const id of knowledgeIds) {
      const result = stmt.run(now, id);
      count += result.changes;
    }
    return count;
  })();

  return { updated };
}
```

**Get access statistics:**
```javascript
function getAccessStats(db, { scope = null, type = null } = {}) {
  let sql = `
    SELECT
      type,
      scope,
      COUNT(*) as total_count,
      SUM(access_count) as total_accesses,
      AVG(access_count) as avg_accesses,
      MAX(access_count) as max_accesses,
      AVG(CASE WHEN last_accessed IS NOT NULL THEN (? - last_accessed) ELSE NULL END) as avg_age_ms
    FROM knowledge
    WHERE 1=1
  `;

  const params = [Date.now()];

  if (scope) {
    sql += ' AND scope = ?';
    params.push(scope);
  }

  if (type) {
    sql += ' AND type = ?';
    params.push(type);
  }

  sql += ' GROUP BY type, scope';

  return db.prepare(sql).all(...params);
}
```

This provides the foundation for access-based ranking (KNOW-11).
  </action>
  <verify>
```javascript
const { trackAccess, getAccessStats } = require('./get-shit-done/bin/knowledge-lifecycle.js');

trackAccess(db, 1);
trackAccess(db, 1);
trackAccess(db, 1);

const stats = getAccessStats(db);
console.log(stats[0].total_accesses); // 3
```
  </verify>
  <done>
trackAccess increments access_count and updates last_accessed. trackAccessBatch handles multiple IDs efficiently. getAccessStats provides aggregate metrics.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement staleness tracking</name>
  <files>get-shit-done/bin/knowledge-lifecycle.js</files>
  <action>
Add staleness scoring (KNOW-10):

**Staleness score calculation:**
```javascript
function getStalenessScore(db, knowledgeId) {
  const row = db.prepare(`
    SELECT
      id,
      type,
      created_at,
      last_accessed,
      access_count,
      expires_at
    FROM knowledge
    WHERE id = ?
  `).get(knowledgeId);

  if (!row) return null;

  const now = Date.now();
  const ageMs = now - row.created_at;
  const ageDays = ageMs / (24 * 60 * 60 * 1000);

  // Time since last access (or creation if never accessed)
  const lastAccessMs = row.last_accessed || row.created_at;
  const dormantMs = now - lastAccessMs;
  const dormantDays = dormantMs / (24 * 60 * 60 * 1000);

  // Volatility based on type
  const volatility = {
    temp_note: 0.9,    // High volatility - stales quickly
    summary: 0.7,      // Medium-high
    decision: 0.3,     // Low volatility - decisions age slowly
    lesson: 0.1        // Very low - lessons remain relevant
  }[row.type] || 0.5;

  // Staleness formula:
  // - Higher dormancy increases staleness
  // - Higher access count decreases staleness (frequently used = still relevant)
  // - Volatility scales the decay rate
  const accessFactor = 1 / (1 + Math.log(1 + row.access_count));
  const timeFactor = dormantDays / 30; // Normalize to 30-day scale
  const staleness = Math.min(1.0, timeFactor * volatility * accessFactor);

  return {
    id: row.id,
    type: row.type,
    age_days: ageDays,
    dormant_days: dormantDays,
    access_count: row.access_count,
    volatility,
    staleness_score: staleness,
    expires_at: row.expires_at,
    is_stale: staleness > 0.7  // Threshold for "stale" classification
  };
}
```

**Batch staleness check:**
```javascript
function getStaleKnowledge(db, { threshold = 0.7, limit = 100, scope = null } = {}) {
  let sql = `
    SELECT id FROM knowledge
    WHERE (expires_at IS NULL OR expires_at > ?)
  `;

  const params = [Date.now()];

  if (scope) {
    sql += ' AND scope = ?';
    params.push(scope);
  }

  sql += ' ORDER BY last_accessed ASC NULLS FIRST LIMIT ?';
  params.push(limit);

  const candidates = db.prepare(sql).all(...params);

  return candidates
    .map(row => getStalenessScore(db, row.id))
    .filter(score => score && score.staleness_score > threshold)
    .sort((a, b) => b.staleness_score - a.staleness_score);
}
```

**Mark knowledge as refreshed:**
```javascript
function markRefreshed(db, knowledgeId) {
  const now = Date.now();
  db.prepare(`
    UPDATE knowledge
    SET last_accessed = ?
    WHERE id = ?
  `).run(now, knowledgeId);
  return { success: true };
}
```

Export all lifecycle functions.
  </action>
  <verify>
```javascript
const { getStalenessScore, getStaleKnowledge } = require('./get-shit-done/bin/knowledge-lifecycle.js');

// Insert old knowledge
insertKnowledge(db, {
  content: 'Old decision from 60 days ago',
  type: 'decision',
  scope: 'project',
  ttlCategory: 'permanent'
});

// Manually set created_at to 60 days ago
const id = 1;
db.prepare('UPDATE knowledge SET created_at = ?, last_accessed = NULL WHERE id = ?')
  .run(Date.now() - 60 * 24 * 60 * 60 * 1000, id);

const score = getStalenessScore(db, id);
console.log(score.staleness_score); // Should be > 0 due to age
console.log(score.is_stale); // true if > 0.7
```
  </verify>
  <done>
getStalenessScore computes staleness based on age, dormancy, access count, and type volatility. getStaleKnowledge finds candidates above threshold. markRefreshed resets dormancy timer.
  </done>
</task>

</tasks>

<verification>
1. cleanupExpired removes all expired entries atomically
2. Vector and FTS entries cleaned up together (no orphans)
3. WAL checkpoint after large cleanup (>100 entries)
4. trackAccess increments access_count and last_accessed
5. Staleness score considers: dormancy, access count, type volatility
6. getStaleKnowledge returns entries above staleness threshold
</verification>

<success_criteria>
- knowledge-lifecycle.js exports: cleanupExpired, checkpointWAL, trackAccess, trackAccessBatch, getAccessStats, getStalenessScore, getStaleKnowledge, markRefreshed
- TTL cleanup runs atomically across knowledge, knowledge_fts, knowledge_vec tables
- Access tracking updates both count and timestamp
- Staleness formula: timeFactor * volatility * accessFactor
- Type volatility: temp_note=0.9, summary=0.7, decision=0.3, lesson=0.1
- Stale threshold default: 0.7
</success_criteria>

<output>
After completion, create `.planning/phases/03-knowledge-system-foundation/03-04-SUMMARY.md`
</output>
