---
phase: 03-knowledge-system-foundation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - get-shit-done/bin/knowledge-crud.js
autonomous: true

must_haves:
  truths:
    - "Knowledge can be inserted with content, type, scope, and TTL category"
    - "Embeddings are normalized before vector storage"
    - "Content hash computed for deduplication"
    - "TTL categories map to expiration timestamps"
    - "Knowledge can be updated and deleted"
  artifacts:
    - path: "get-shit-done/bin/knowledge-crud.js"
      provides: "CRUD operations for knowledge entries"
      min_lines: 150
      exports: ["insertKnowledge", "updateKnowledge", "deleteKnowledge", "getKnowledge"]
  key_links:
    - from: "get-shit-done/bin/knowledge-crud.js"
      to: "get-shit-done/bin/knowledge-db.js"
      via: "require"
      pattern: "require.*knowledge-db"
---

<objective>
Implement CRUD operations for knowledge entries with TTL categories and vector embedding support.

Purpose: Provide the data access layer for creating, reading, updating, and deleting knowledge entries with proper TTL handling and embedding normalization.

Output: `knowledge-crud.js` module with all CRUD operations.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-knowledge-system-foundation/03-RESEARCH.md
@.planning/phases/03-knowledge-system-foundation/03-01-SUMMARY.md
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create knowledge-crud.js with insert operation</name>
  <files>get-shit-done/bin/knowledge-crud.js</files>
  <action>
Create new file `get-shit-done/bin/knowledge-crud.js` implementing:

**TTL category mapping:**
```javascript
const TTL_CATEGORIES = {
  permanent: null,                        // Never expires (lessons, patterns)
  long_term: 90 * 24 * 60 * 60 * 1000,   // 90 days (decisions)
  short_term: 7 * 24 * 60 * 60 * 1000,   // 7 days (summaries)
  ephemeral: 24 * 60 * 60 * 1000         // 24 hours (temp notes)
};
```

**Insert function:**
```javascript
function insertKnowledge(db, {
  content,
  type,                    // 'decision', 'lesson', 'summary', 'temp_note'
  scope,                   // 'global' or 'project'
  ttlCategory,             // 'permanent', 'long_term', 'short_term', 'ephemeral'
  embedding = null,        // Float32Array or null (embedding optional initially)
  metadata = {}
}) {
  // 1. Compute content hash (SHA-256)
  const hash = crypto.createHash('sha256').update(content).digest('hex');

  // 2. Calculate expires_at from TTL category
  const now = Date.now();
  const ttlMs = TTL_CATEGORIES[ttlCategory];
  const expiresAt = ttlMs ? now + ttlMs : null;

  // 3. Insert into main table
  const stmt = db.prepare(`
    INSERT INTO knowledge (content, type, scope, created_at, expires_at, access_count, last_accessed, content_hash, metadata)
    VALUES (?, ?, ?, ?, ?, 0, ?, ?, ?)
  `);

  const result = db.transaction(() => {
    const info = stmt.run(content, type, scope, now, expiresAt, now, hash, JSON.stringify(metadata));
    const id = info.lastInsertRowid;

    // 4. Insert embedding if provided (FTS5 handled by trigger)
    if (embedding && db.vectorEnabled) {
      const normalized = normalizeEmbedding(embedding);
      db.prepare('INSERT INTO knowledge_vec (rowid, embedding) VALUES (?, ?)').run(id, normalized);
    }

    return id;
  })();

  return { id: result, content_hash: hash };
}
```

**Embedding normalization:**
```javascript
function normalizeEmbedding(embedding) {
  // L2 normalization for cosine similarity
  const arr = embedding instanceof Float32Array ? embedding : new Float32Array(embedding);
  const norm = Math.sqrt(arr.reduce((sum, val) => sum + val * val, 0));
  if (norm < 1e-12) return arr; // Avoid division by zero
  return new Float32Array(arr.map(v => v / norm));
}
```

**Content hash for deduplication:**
Uses crypto.createHash('sha256') - supports KNOW-16 (content hash deduplication).

Follow conventions: camelCase functions, snake_case object keys, section dividers.
  </action>
  <verify>
Create test:
```javascript
const { openKnowledgeDB, closeKnowledgeDB } = require('./get-shit-done/bin/knowledge-db.js');
const { insertKnowledge } = require('./get-shit-done/bin/knowledge-crud.js');
const db = openKnowledgeDB('project');
const result = insertKnowledge(db, {
  content: 'Test decision',
  type: 'decision',
  scope: 'project',
  ttlCategory: 'long_term'
});
console.log(result); // { id: 1, content_hash: '...' }
closeKnowledgeDB(db);
```
  </verify>
  <done>
insertKnowledge creates knowledge entries with content hash, TTL expiration, and optional embedding.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add get, update, and delete operations</name>
  <files>get-shit-done/bin/knowledge-crud.js</files>
  <action>
Add remaining CRUD operations to knowledge-crud.js:

**Get by ID:**
```javascript
function getKnowledge(db, id) {
  const row = db.prepare('SELECT * FROM knowledge WHERE id = ?').get(id);
  if (!row) return null;
  return {
    ...row,
    metadata: row.metadata ? JSON.parse(row.metadata) : {}
  };
}
```

**Get by hash (for deduplication):**
```javascript
function getKnowledgeByHash(db, contentHash) {
  const row = db.prepare('SELECT * FROM knowledge WHERE content_hash = ?').get(contentHash);
  if (!row) return null;
  return {
    ...row,
    metadata: row.metadata ? JSON.parse(row.metadata) : {}
  };
}
```

**Update knowledge:**
```javascript
function updateKnowledge(db, id, updates) {
  // updates can include: content, type, ttlCategory, metadata, embedding
  const current = getKnowledge(db, id);
  if (!current) return { success: false, error: 'not_found' };

  const now = Date.now();
  const fields = [];
  const values = [];

  if (updates.content !== undefined) {
    fields.push('content = ?', 'content_hash = ?');
    const hash = crypto.createHash('sha256').update(updates.content).digest('hex');
    values.push(updates.content, hash);
  }

  if (updates.type !== undefined) {
    fields.push('type = ?');
    values.push(updates.type);
  }

  if (updates.ttlCategory !== undefined) {
    const ttlMs = TTL_CATEGORIES[updates.ttlCategory];
    fields.push('expires_at = ?');
    values.push(ttlMs ? now + ttlMs : null);
  }

  if (updates.metadata !== undefined) {
    fields.push('metadata = ?');
    values.push(JSON.stringify(updates.metadata));
  }

  values.push(id);

  db.transaction(() => {
    if (fields.length > 0) {
      db.prepare(`UPDATE knowledge SET ${fields.join(', ')} WHERE id = ?`).run(...values);
    }

    if (updates.embedding && db.vectorEnabled) {
      const normalized = normalizeEmbedding(updates.embedding);
      db.prepare('DELETE FROM knowledge_vec WHERE rowid = ?').run(id);
      db.prepare('INSERT INTO knowledge_vec (rowid, embedding) VALUES (?, ?)').run(id, normalized);
    }
  })();

  return { success: true };
}
```

**Delete knowledge:**
```javascript
function deleteKnowledge(db, id) {
  const result = db.transaction(() => {
    // Delete from vec (FTS5 handled by trigger)
    if (db.vectorEnabled) {
      db.prepare('DELETE FROM knowledge_vec WHERE rowid = ?').run(id);
    }
    const info = db.prepare('DELETE FROM knowledge WHERE id = ?').run(id);
    return info.changes;
  })();

  return { deleted: result > 0 };
}
```

**Bulk get by type:**
```javascript
function getKnowledgeByType(db, type, { limit = 100, scope = null } = {}) {
  const params = [type];
  let query = 'SELECT * FROM knowledge WHERE type = ?';
  if (scope) {
    query += ' AND scope = ?';
    params.push(scope);
  }
  query += ' ORDER BY access_count DESC, created_at DESC LIMIT ?';
  params.push(limit);

  return db.prepare(query).all(...params).map(row => ({
    ...row,
    metadata: row.metadata ? JSON.parse(row.metadata) : {}
  }));
}
```

Export all functions.
  </action>
  <verify>
Test update and delete:
```javascript
const { updateKnowledge, deleteKnowledge, getKnowledge } = require('./get-shit-done/bin/knowledge-crud.js');
// Update
updateKnowledge(db, 1, { content: 'Updated content', ttlCategory: 'permanent' });
console.log(getKnowledge(db, 1).content); // 'Updated content'
// Delete
deleteKnowledge(db, 1);
console.log(getKnowledge(db, 1)); // null
```
  </verify>
  <done>
getKnowledge, getKnowledgeByHash, getKnowledgeByType, updateKnowledge, and deleteKnowledge all work correctly with proper transaction handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add type-to-TTL default mapping</name>
  <files>get-shit-done/bin/knowledge-crud.js</files>
  <action>
Add automatic TTL category inference based on knowledge type:

**Type defaults (per KNOW-08):**
```javascript
const TYPE_TO_TTL = {
  lesson: 'permanent',      // Lessons and patterns never expire
  decision: 'long_term',    // Decisions last 90 days
  summary: 'short_term',    // Summaries last 7 days
  temp_note: 'ephemeral'    // Temp notes last 24 hours
};
```

**Update insertKnowledge:**
```javascript
function insertKnowledge(db, {
  content,
  type,
  scope,
  ttlCategory = null,  // If not provided, infer from type
  embedding = null,
  metadata = {}
}) {
  const effectiveTTL = ttlCategory || TYPE_TO_TTL[type] || 'short_term';
  // ... rest of implementation uses effectiveTTL
}
```

**Add TTL refresh function:**
For knowledge that should extend TTL on access (e.g., frequently-used decisions):
```javascript
function refreshTTL(db, id, ttlCategory = null) {
  const current = getKnowledge(db, id);
  if (!current) return { success: false, error: 'not_found' };

  const effectiveTTL = ttlCategory || TYPE_TO_TTL[current.type] || 'short_term';
  const ttlMs = TTL_CATEGORIES[effectiveTTL];
  const now = Date.now();
  const expiresAt = ttlMs ? now + ttlMs : null;

  db.prepare('UPDATE knowledge SET expires_at = ? WHERE id = ?').run(expiresAt, id);
  return { success: true, expires_at: expiresAt };
}
```

This supports the memory lifecycle requirements (KNOW-08) with sensible defaults.
  </action>
  <verify>
Test TTL inference:
```javascript
const result = insertKnowledge(db, {
  content: 'A lesson learned',
  type: 'lesson',
  scope: 'project'
  // No ttlCategory - should infer 'permanent'
});
const knowledge = getKnowledge(db, result.id);
console.log(knowledge.expires_at); // null (permanent)
```
  </verify>
  <done>
Type-to-TTL mapping provides sensible defaults. refreshTTL extends expiration for frequently-accessed knowledge.
  </done>
</task>

</tasks>

<verification>
1. insertKnowledge creates entries with correct TTL expiration
2. Content hash computed and stored for deduplication
3. Embedding normalized before vector insertion
4. Update and delete operations work within transactions
5. Type-to-TTL defaults match KNOW-08 categories
6. refreshTTL extends expiration timestamp
</verification>

<success_criteria>
- knowledge-crud.js exports: insertKnowledge, getKnowledge, getKnowledgeByHash, getKnowledgeByType, updateKnowledge, deleteKnowledge, refreshTTL
- TTL categories: permanent (null), long_term (90d), short_term (7d), ephemeral (24h)
- Type defaults: lesson=permanent, decision=long_term, summary=short_term, temp_note=ephemeral
- Content hash uses SHA-256
- Embedding normalization uses L2 norm
- All operations use transactions for atomicity
</success_criteria>

<output>
After completion, create `.planning/phases/03-knowledge-system-foundation/03-02-SUMMARY.md`
</output>
