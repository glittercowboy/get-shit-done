---
phase: 10-installation-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/install-orchestrator.js
  - scripts/install-modules.js
  - package.json
  - get-shit-done/modules/validator/package.json
  - get-shit-done/modules/circuit-breaker/package.json
  - get-shit-done/modules/escalation/package.json
  - get-shit-done/modules/feedback/package.json
  - get-shit-done/modules/learning/package.json
autonomous: true

must_haves:
  truths:
    - "User can run npm run install:gsd from repo root"
    - "Installation detects npx github:user/repo scenario and handles correctly"
    - "All npm dependencies across modules install with single command"
    - "Module stubs exist with package.json for future implementation"
  artifacts:
    - path: "scripts/install-orchestrator.js"
      provides: "Main installation entry point"
      min_lines: 80
    - path: "scripts/install-modules.js"
      provides: "NPM dependency installation across workspaces"
      min_lines: 50
    - path: "package.json"
      provides: "Workspaces config and install:gsd script"
      contains: "workspaces"
  key_links:
    - from: "package.json"
      to: "scripts/install-orchestrator.js"
      via: "npm run install:gsd script"
      pattern: "install:gsd.*install-orchestrator"
    - from: "scripts/install-orchestrator.js"
      to: "scripts/install-modules.js"
      via: "require call"
      pattern: "require.*install-modules"
---

<objective>
Create the installation orchestrator and npm workspace configuration for unified dependency management.

Purpose: Enable single-command installation that works for both direct clones and npx github:user/repo installs.
Output: scripts/install-orchestrator.js, scripts/install-modules.js, workspace configuration, module stubs
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-module-repository-consolidation-move-external-modules-validator-circuit-breaker-escalation-feedback-learning-into-repo-with-installation-script-and-proper-structure/10-RESEARCH.md
@package.json
@bin/install.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create module stub structure with package.json files</name>
  <files>
    get-shit-done/modules/validator/package.json
    get-shit-done/modules/validator/index.js
    get-shit-done/modules/circuit-breaker/package.json
    get-shit-done/modules/circuit-breaker/index.js
    get-shit-done/modules/escalation/package.json
    get-shit-done/modules/escalation/index.js
    get-shit-done/modules/feedback/package.json
    get-shit-done/modules/feedback/index.js
    get-shit-done/modules/learning/package.json
    get-shit-done/modules/learning/index.js
  </files>
  <action>
Create directory structure for external module consolidation at get-shit-done/modules/.

For each module (validator, circuit-breaker, escalation, feedback, learning):

1. Create package.json with:
   - name: "@gsd/{module-name}"
   - version: "0.1.0"
   - description: "GSD {Module Name} - placeholder for Phase 2 implementation"
   - main: "index.js"
   - private: true (prevents accidental publish)

2. Create index.js stub that exports placeholder functions:
   - For validator: exports validate(), validateTask()
   - For circuit-breaker: exports CircuitBreaker class with fire(), getState()
   - For escalation: exports escalate(), getEscalationLevel()
   - For feedback: exports collectFeedback(), getFeedbackStats()
   - For learning: exports learn(), getPatterns()

Each stub should:
- Log a warning that the module is a placeholder
- Return sensible defaults (true for validation, null for data)
- Document future implementation intent in JSDoc comments

This creates the structure for npm workspaces without requiring actual implementation.
  </action>
  <verify>
    ls -la get-shit-done/modules/*/package.json && node -e "require('./get-shit-done/modules/validator')"
  </verify>
  <done>
    Five module directories exist with package.json and index.js stubs that can be required without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure npm workspaces and install:gsd script</name>
  <files>
    package.json
  </files>
  <action>
Update root package.json to add npm workspaces configuration and installation script.

Add to package.json:

1. "workspaces" array:
   ```json
   "workspaces": [
     "get-shit-done/modules/*",
     "mcp-servers/*"
   ]
   ```

2. Add to "scripts":
   ```json
   "install:gsd": "node scripts/install-orchestrator.js",
   "health-check": "node scripts/health-check.js",
   "uninstall:gsd": "bash scripts/uninstall.sh"
   ```

IMPORTANT: Preserve all existing fields (name, version, dependencies, etc.). This is a merge, not a replacement.

Note: npm workspaces (npm 7+) provides automatic hoisting of shared dependencies and unified install command.
  </action>
  <verify>
    node -e "const pkg = require('./package.json'); console.log(pkg.workspaces, pkg.scripts['install:gsd'])"
  </verify>
  <done>
    package.json contains workspaces array and install:gsd script pointing to orchestrator
  </done>
</task>

<task type="auto">
  <name>Task 3: Create installation orchestrator with npx detection</name>
  <files>
    scripts/install-orchestrator.js
    scripts/install-modules.js
  </files>
  <action>
Create the main installation entry point that orchestrates all installation steps.

1. Create scripts/install-orchestrator.js:

```javascript
#!/usr/bin/env node
/**
 * GSD Installation Orchestrator
 *
 * Handles installation from multiple scenarios:
 * - Direct clone: git clone && npm run install:gsd
 * - npx from npm: npx get-shit-done-cc (uses bin/install.js)
 * - npx from GitHub fork: npx github:user/get-shit-done
 *
 * CRITICAL: Detect npx github: scenario where node_modules may not exist
 * and the script runs from a temporary npm cache directory.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Detect installation context
function detectContext() {
  const cwd = process.cwd();
  const scriptDir = __dirname;

  // Check if running from npm cache (npx github: scenario)
  const isNpxGithub = scriptDir.includes('_npx') ||
                      scriptDir.includes('.npm/_cacache') ||
                      !fs.existsSync(path.join(scriptDir, '..', 'node_modules'));

  // Check if running from cloned repo
  const hasPackageJson = fs.existsSync(path.join(cwd, 'package.json'));
  const hasGsdDir = fs.existsSync(path.join(cwd, 'get-shit-done'));

  return {
    isNpxGithub,
    isDirectClone: hasPackageJson && hasGsdDir && !isNpxGithub,
    cwd,
    scriptDir,
    projectRoot: isNpxGithub ? cwd : path.resolve(scriptDir, '..')
  };
}

async function main() {
  console.log('\n  GSD Installation\n');

  const context = detectContext();

  if (context.isNpxGithub) {
    console.log('  Detected: npx github:user/repo installation');
    console.log('  Redirecting to standard installer...\n');

    // For npx github: scenario, delegate to bin/install.js
    // which handles the interactive installation flow
    const installScript = path.join(context.scriptDir, '..', 'bin', 'install.js');
    if (fs.existsSync(installScript)) {
      require(installScript);
      return;
    } else {
      console.error('  Error: bin/install.js not found');
      process.exit(1);
    }
  }

  console.log('  Detected: Direct repository installation\n');

  try {
    // Step 1: Install npm dependencies via workspaces
    console.log('  1/6 Installing npm dependencies...');
    require('./install-modules.js')();

    // Step 2: Whisper models (handled by Plan 02)
    console.log('  2/6 Whisper model installation...');
    const whisperInstaller = path.join(__dirname, 'install-whisper.js');
    if (fs.existsSync(whisperInstaller)) {
      require(whisperInstaller)();
    } else {
      console.log('       (skipped - whisper installer not yet created)');
    }

    // Step 3: Claude Code hooks (handled by Plan 03)
    console.log('  3/6 Installing Claude Code hooks...');
    const hookInstaller = path.join(__dirname, 'install-hooks.js');
    if (fs.existsSync(hookInstaller)) {
      require(hookInstaller)();
    } else {
      console.log('       (skipped - hook installer not yet created)');
    }

    // Step 4: MCP server config (handled by Plan 03)
    console.log('  4/6 Configuring MCP servers...');
    const mcpInstaller = path.join(__dirname, 'install-mcp.js');
    if (fs.existsSync(mcpInstaller)) {
      require(mcpInstaller)();
    } else {
      console.log('       (skipped - MCP installer not yet created)');
    }

    // Step 5: .env template (handled by Plan 04)
    console.log('  5/6 Generating .env.template...');
    const envGenerator = path.join(__dirname, 'generate-env-template.js');
    if (fs.existsSync(envGenerator)) {
      require(envGenerator)();
    } else {
      console.log('       (skipped - env generator not yet created)');
    }

    // Step 6: Health check (handled by Plan 02)
    console.log('  6/6 Running health check...');
    const healthCheck = path.join(__dirname, 'health-check.js');
    if (fs.existsSync(healthCheck)) {
      require(healthCheck)();
    } else {
      console.log('       (skipped - health check not yet created)');
    }

    console.log('\n  Installation complete!\n');

  } catch (error) {
    console.error('\n  Installation failed:', error.message);
    console.error('  Run with DEBUG=1 for detailed logs\n');
    process.exit(1);
  }
}

main();
```

2. Create scripts/install-modules.js:

```javascript
#!/usr/bin/env node
/**
 * NPM Workspace Dependency Installer
 *
 * Uses npm workspaces to install dependencies for all modules:
 * - Root package.json
 * - get-shit-done/modules/*
 * - mcp-servers/*
 */

const { execSync } = require('child_process');
const path = require('path');
const fs = require('fs');

function installModules() {
  const projectRoot = path.resolve(__dirname, '..');

  // Check npm version (workspaces require npm 7+)
  try {
    const npmVersion = execSync('npm --version', { encoding: 'utf8' }).trim();
    const majorVersion = parseInt(npmVersion.split('.')[0], 10);

    if (majorVersion < 7) {
      console.log('       npm version:', npmVersion);
      console.log('       Warning: npm workspaces require npm 7+');
      console.log('       Falling back to sequential install...');
      return fallbackInstall(projectRoot);
    }
  } catch (e) {
    console.log('       Warning: Could not determine npm version');
  }

  // Use npm workspaces for unified install
  console.log('       Running npm install with workspaces...');

  try {
    execSync('npm install', {
      cwd: projectRoot,
      stdio: process.env.DEBUG ? 'inherit' : 'pipe',
      timeout: 300000 // 5 minutes
    });
    console.log('       Done');
  } catch (error) {
    if (process.env.DEBUG) {
      console.error('       npm install failed:', error.message);
    }
    throw new Error('npm install failed - check node_modules permissions');
  }
}

function fallbackInstall(projectRoot) {
  // Install root dependencies
  console.log('       Installing root dependencies...');
  execSync('npm install', { cwd: projectRoot, stdio: 'pipe' });

  // Install MCP server dependencies
  const mcpDir = path.join(projectRoot, 'mcp-servers', 'telegram-mcp');
  if (fs.existsSync(path.join(mcpDir, 'package.json'))) {
    console.log('       Installing telegram-mcp dependencies...');
    execSync('npm install', { cwd: mcpDir, stdio: 'pipe' });
  }

  console.log('       Done');
}

module.exports = installModules;

// Allow direct execution
if (require.main === module) {
  installModules();
}
```

Both scripts must be executable (chmod +x) for direct invocation.
  </action>
  <verify>
    node scripts/install-orchestrator.js --help 2>&1 || node -e "require('./scripts/install-modules.js')" && echo "Scripts load successfully"
  </verify>
  <done>
    scripts/install-orchestrator.js detects npx github: scenario and delegates appropriately.
    scripts/install-modules.js handles npm workspace installation with fallback for npm 6.
    Both scripts are executable and can be required as modules.
  </done>
</task>

</tasks>

<verification>
1. Run: npm run install:gsd (should complete without errors)
2. Verify: ls get-shit-done/modules/*/package.json (5 modules)
3. Verify: node -e "require('./get-shit-done/modules/validator')" (loads without error)
4. Verify: grep -q "workspaces" package.json (workspace config present)
</verification>

<success_criteria>
- npm run install:gsd executes scripts/install-orchestrator.js
- Orchestrator detects installation context (direct clone vs npx github:)
- Module stubs exist and are importable without errors
- npm workspaces configured for get-shit-done/modules/* and mcp-servers/*
- All dependencies install with single npm install command
</success_criteria>

<output>
After completion, create `.planning/phases/10-module-repository-consolidation-move-external-modules-validator-circuit-breaker-escalation-feedback-learning-into-repo-with-installation-script-and-proper-structure/10-01-SUMMARY.md`
</output>
