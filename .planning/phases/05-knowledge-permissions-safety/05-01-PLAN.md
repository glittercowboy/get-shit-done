---
phase: 05-knowledge-permissions-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/bin/knowledge-db.js
  - get-shit-done/bin/knowledge-permissions.js
autonomous: true

must_haves:
  truths:
    - "User can grant permissions with action patterns, scopes, and limits"
    - "User can revoke permissions by token"
    - "System checks if action is permitted before execution"
    - "Permissions expire based on TTL and are filtered from active grants"
  artifacts:
    - path: "get-shit-done/bin/knowledge-permissions.js"
      provides: "Permission grant/revoke/check logic"
      exports: ["grantPermission", "revokePermission", "checkPermission", "listActivePermissions"]
    - path: "get-shit-done/bin/knowledge-db.js"
      provides: "Extended schema with permissions table"
      contains: "CREATE TABLE IF NOT EXISTS permissions"
  key_links:
    - from: "get-shit-done/bin/knowledge-permissions.js"
      to: "get-shit-done/bin/knowledge-db.js"
      via: "openKnowledgeDB for database access"
      pattern: "openKnowledgeDB"
---

<objective>
Create permission storage and management infrastructure

Purpose: Enable users to grant explicit permissions with boundaries (KNOW-23, KNOW-24). Permissions are stored in SQLite, matched via pattern rules, and tracked with limits and expiration.

Output: knowledge-permissions.js module with grant/revoke/check functions, schema migration for permissions table
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-knowledge-permissions-safety/05-RESEARCH.md
@get-shit-done/bin/knowledge-db.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend schema with permissions table</name>
  <files>get-shit-done/bin/knowledge-db.js</files>
  <action>
Add permissions table to createSchema() function after existing tables:

```sql
CREATE TABLE IF NOT EXISTS permissions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  grant_token TEXT UNIQUE NOT NULL,
  action_pattern TEXT NOT NULL,
  scope TEXT NOT NULL DEFAULT 'global',
  limits TEXT,
  granted_at INTEGER NOT NULL,
  expires_at INTEGER,
  revoked_at INTEGER,
  metadata TEXT
);

CREATE INDEX IF NOT EXISTS idx_permissions_pattern ON permissions(action_pattern);
CREATE INDEX IF NOT EXISTS idx_permissions_active ON permissions(revoked_at) WHERE revoked_at IS NULL;
```

Update SCHEMA_VERSION to 2 and add migration logic in migrateDatabase() to create permissions table if upgrading from version 1.
  </action>
  <verify>
Run `node -e "const db = require('./get-shit-done/bin/knowledge-db.js'); const conn = db.openKnowledgeDB('project'); console.log(conn.db.prepare('SELECT name FROM sqlite_master WHERE type=\\'table\\' AND name=\\'permissions\\'').get())"` - should show permissions table
  </verify>
  <done>Permissions table created with indexes, schema version 2, migration works from v1</done>
</task>

<task type="auto">
  <name>Task 2: Create permission management module</name>
  <files>get-shit-done/bin/knowledge-permissions.js</files>
  <action>
Create knowledge-permissions.js with:

1. **grantPermission(db, options)** - Grant permission
   - Generate crypto.randomBytes(16).toString('hex') for grant_token
   - Validate limits schema (max_cost: positive number, max_count: positive integer, path: string)
   - Insert into permissions table with granted_at = Date.now()
   - Calculate expires_at from optional ttl parameter
   - Return { granted: true, grant_id, grant_token, expires_at } or { granted: false, error }

2. **revokePermission(db, grantToken)** - Revoke by token
   - UPDATE permissions SET revoked_at = Date.now() WHERE grant_token = ? AND revoked_at IS NULL
   - Return { revoked: true, grant_token } or { revoked: false, error: 'not found or already revoked' }

3. **checkPermission(db, action, context = {})** - Check if action permitted
   - Get active grants: revoked_at IS NULL AND (expires_at IS NULL OR expires_at > now)
   - For each grant, call matchesPattern(action, grant.action_pattern)
   - matchesPattern supports: exact match, wildcard suffix (aws:*), glob patterns (delete_file:/test/*)
   - If match found, check limits via checkLimits()
   - Return { permitted: true, grant_id, grant_token, limits } or { permitted: false, reason }

4. **listActivePermissions(db)** - List all active grants
   - SELECT with expires_in calculated column
   - Return array of grants with human-readable expiration

5. **matchesPattern(action, pattern)** - Pattern matching helper
   - Exact match: action === pattern
   - Wildcard suffix: pattern.endsWith(':*') and action.startsWith(prefix + ':')
   - Glob: pattern.includes('*') and regex test

6. **validateLimits(limits)** - Validate limit schema
   - Check max_cost, max_count, path types
   - Return { valid: true } or { valid: false, error: string }

Export all functions. Use crypto module for token generation.
  </action>
  <verify>
Run:
```bash
node -e "
const { openKnowledgeDB } = require('./get-shit-done/bin/knowledge-db.js');
const { grantPermission, checkPermission, revokePermission } = require('./get-shit-done/bin/knowledge-permissions.js');
const conn = openKnowledgeDB('project');
const grant = grantPermission(conn.db, { action: 'delete_file:/test/*', scope: 'project', limits: { max_count: 10 }, ttl: 3600000 });
console.log('Grant:', grant.granted);
const check = checkPermission(conn.db, 'delete_file:/test/foo.txt', {});
console.log('Check:', check.permitted);
const revoke = revokePermission(conn.db, grant.grant_token);
console.log('Revoke:', revoke.revoked);
const check2 = checkPermission(conn.db, 'delete_file:/test/foo.txt', {});
console.log('After revoke:', check2.permitted);
"
```
Should output: Grant: true, Check: true, Revoke: true, After revoke: false
  </verify>
  <done>Permission module with grant/revoke/check functions, pattern matching, limit validation</done>
</task>

<task type="auto">
  <name>Task 3: Add limit tracking functions</name>
  <files>get-shit-done/bin/knowledge-permissions.js</files>
  <action>
Add limit tracking to knowledge-permissions.js:

1. **checkLimits(db, grantId, action, limits)** - Check if within limits
   - If limits.max_count defined: COUNT usage for this grant_id in permission_usage table
   - If limits.max_cost defined: SUM cost for this grant_id in cost_tracking table (added in plan 03)
   - Return { allowed: true } or { allowed: false, exceeded: 'max_count' | 'max_cost' }

2. **recordPermissionUsage(db, grantId, action)** - Record permission use
   - Insert into permission_usage table (id, grant_id, action, timestamp)
   - Return { recorded: true }

3. Add permission_usage table to schema in knowledge-db.js:
```sql
CREATE TABLE IF NOT EXISTS permission_usage (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  grant_id INTEGER NOT NULL,
  action TEXT NOT NULL,
  timestamp INTEGER NOT NULL,
  FOREIGN KEY (grant_id) REFERENCES permissions(id)
);
CREATE INDEX IF NOT EXISTS idx_permission_usage_grant ON permission_usage(grant_id);
```

Update checkPermission to call checkLimits when limits exist on matched grant.
  </action>
  <verify>
Run:
```bash
node -e "
const { openKnowledgeDB } = require('./get-shit-done/bin/knowledge-db.js');
const { grantPermission, checkPermission, recordPermissionUsage } = require('./get-shit-done/bin/knowledge-permissions.js');
const conn = openKnowledgeDB('project');
const grant = grantPermission(conn.db, { action: 'run_test:*', limits: { max_count: 2 } });
recordPermissionUsage(conn.db, grant.grant_id, 'run_test:unit');
recordPermissionUsage(conn.db, grant.grant_id, 'run_test:integration');
const check = checkPermission(conn.db, 'run_test:e2e', {});
console.log('After 2 uses, max_count 2:', check.permitted, check.reason);
"
```
Should output: After 2 uses, max_count 2: false limit_exceeded
  </verify>
  <done>Limit tracking with usage recording and enforcement in permission checks</done>
</task>

</tasks>

<verification>
1. Schema version is 2 with permissions and permission_usage tables
2. All permission functions work: grant, revoke, check, list
3. Pattern matching handles exact, wildcard, and glob patterns
4. Limit enforcement prevents exceeding max_count
5. Expired and revoked permissions are excluded from checks
</verification>

<success_criteria>
- Permission grants stored in SQLite with revocable tokens
- Pattern-based permission matching works for action strings
- Limits (max_count) enforced via usage tracking
- Module exports all required functions
- Tests demonstrate full grant/use/exceed/revoke lifecycle
</success_criteria>

<output>
After completion, create `.planning/phases/05-knowledge-permissions-safety/05-01-SUMMARY.md`
</output>
